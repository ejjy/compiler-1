!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AR	Makefile	/^AR= gar$/;"	m
ARCHIVE_NEW	Makefile	/^ARCHIVE_NEW= -cr$/;"	m
ASSIGN	ast-parse.cc	/^     ASSIGN = 264,$/;"	e	enum:yytokentype	file:
ASSIGN	ast-parse.cc	170;"	d	file:
ASSIGN	ast-parse.h	/^     ASSIGN = 264,$/;"	e	enum:yytokentype
ASSIGN	ast-parse.h	130;"	d
ASSIGN	cool-parse.h	/^     ASSIGN = 280,$/;"	e	enum:yytokentype
ASSIGN	cool-parse.h	138;"	d
ASSN	Makefile	/^ASSN = 4$/;"	m
ASTBFLAGS	Makefile	/^ASTBFLAGS = -d -v -y -b ast --debug -p ast_yy$/;"	m
ATTR	ast-parse.cc	/^     ATTR = 261,$/;"	e	enum:yytokentype	file:
ATTR	ast-parse.cc	167;"	d	file:
ATTR	ast-parse.h	/^     ATTR = 261,$/;"	e	enum:yytokentype
ATTR	ast-parse.h	127;"	d
BEGIN	ast-lex.cc	169;"	d	file:
BFLAGS	Makefile	/^BFLAGS = -d -v -y -b cool --debug -p cool_yy$/;"	m
BISON	Makefile	/^BISON= bison ${BFLAGS}$/;"	m
BLOCK	ast-parse.cc	/^     BLOCK = 270,$/;"	e	enum:yytokentype	file:
BLOCK	ast-parse.cc	176;"	d	file:
BLOCK	ast-parse.h	/^     BLOCK = 270,$/;"	e	enum:yytokentype
BLOCK	ast-parse.h	136;"	d
BOOL	ast-parse.cc	/^     BOOL = 283,$/;"	e	enum:yytokentype	file:
BOOL	ast-parse.cc	189;"	d	file:
BOOL	ast-parse.h	/^     BOOL = 283,$/;"	e	enum:yytokentype
BOOL	ast-parse.h	149;"	d
BOOL_CONST	cool-parse.h	/^     BOOL_CONST = 277,$/;"	e	enum:yytokentype
BOOL_CONST	cool-parse.h	135;"	d
BRANCH	ast-parse.cc	/^     BRANCH = 263,$/;"	e	enum:yytokentype	file:
BRANCH	ast-parse.cc	169;"	d	file:
BRANCH	ast-parse.h	/^     BRANCH = 263,$/;"	e	enum:yytokentype
BRANCH	ast-parse.h	129;"	d
Bool	semant.cc	/^    Bool,$/;"	v	file:
Boolean	ast-parse.h	/^typedef int Boolean;$/;"	t
Boolean	cool-parse.h	/^typedef int Boolean;$/;"	t
Boolean	cool.h	/^typedef int Boolean;$/;"	t
CASE	cool-parse.h	/^     CASE = 269,$/;"	e	enum:yytokentype
CASE	cool-parse.h	127;"	d
CC	Makefile	/^CC=g++$/;"	m
CFIL	Makefile	/^CFIL= semant.cc ${CSRC} ${CGEN}$/;"	m
CFLAGS	Makefile	/^CFLAGS=-g -Wall -Wno-unused -Wno-write-strings ${CPPINCLUDE} -DDEBUG$/;"	m
CGEN	Makefile	/^CGEN=$/;"	m
CLASS	Makefile	/^CLASS= cs143$/;"	m
CLASS	ast-parse.cc	/^     CLASS = 259,$/;"	e	enum:yytokentype	file:
CLASS	ast-parse.cc	165;"	d	file:
CLASS	ast-parse.h	/^     CLASS = 259,$/;"	e	enum:yytokentype
CLASS	ast-parse.h	125;"	d
CLASS	cool-parse.h	/^     CLASS = 258,$/;"	e	enum:yytokentype
CLASS	cool-parse.h	116;"	d
CLASSDIR	Makefile	/^CLASSDIR= \/usr\/class\/cs143\/cool$/;"	m
COMP	ast-parse.cc	/^     COMP = 280,$/;"	e	enum:yytokentype	file:
COMP	ast-parse.cc	186;"	d	file:
COMP	ast-parse.h	/^     COMP = 280,$/;"	e	enum:yytokentype
COMP	ast-parse.h	146;"	d
COND	ast-parse.cc	/^     COND = 267,$/;"	e	enum:yytokentype	file:
COND	ast-parse.cc	173;"	d	file:
COND	ast-parse.h	/^     COND = 267,$/;"	e	enum:yytokentype
COND	ast-parse.h	133;"	d
COOL_IO_H	cool-io.h	8;"	d
COOL_TREE_H	cool-tree.h	2;"	d
COOL_TREE_HANDCODE_H	cool-tree.handcode.h	5;"	d
CPPINCLUDE	Makefile	/^CPPINCLUDE= -I. -I${CLASSDIR}\/include\/PA${ASSN} -I${CLASSDIR}\/src\/PA${ASSN}$/;"	m
CSRC	Makefile	/^CSRC= semant-phase.cc symtab_example.cc  handle_flags.cc  ast-lex.cc ast-parse.cc utilities.cc stringtab.cc dumptype.cc tree.cc cool-tree.cc$/;"	m
Case	ast-parse.h	/^typedef class Case_class *Case;$/;"	t	typeref:class:Case_class
Case	cool-parse.h	/^typedef class Case_class *Case;$/;"	t	typeref:class:Case_class
Case	cool-tree.h	/^typedef class Case_class *Case;$/;"	t	typeref:class:Case_class
Case	cool-tree.handcode.h	/^typedef Case_class *Case;$/;"	t
Case_EXTRAS	cool-tree.handcode.h	118;"	d
Case_class	cool-tree.h	/^class Case_class : public tree_node {$/;"	c
Cases	ast-parse.h	/^typedef Cases_class *Cases;$/;"	t
Cases	cool-parse.h	/^typedef Cases_class *Cases;$/;"	t
Cases	cool-tree.h	/^typedef Cases_class *Cases;$/;"	t
Cases	cool-tree.handcode.h	/^typedef Cases_class *Cases;$/;"	t
Cases_class	ast-parse.h	/^typedef list_node<Case> Cases_class;$/;"	t
Cases_class	cool-parse.h	/^typedef list_node<Case> Cases_class;$/;"	t
Cases_class	cool-tree.h	/^typedef list_node<Case> Cases_class;$/;"	t
Cases_class	cool-tree.handcode.h	/^typedef list_node<Case> Cases_class;$/;"	t
ClassTable	semant.cc	/^ClassTable::ClassTable(Classes classes) : semant_errors(0) , error_stream(cerr)$/;"	f	class:ClassTable
ClassTable	semant.h	/^class ClassTable {$/;"	c
ClassTableP	semant.h	/^typedef ClassTable *ClassTableP;$/;"	t
Class_	ast-parse.h	/^typedef class Class__class *Class_;$/;"	t	typeref:class:Class__class
Class_	cool-parse.h	/^typedef class Class__class *Class_;$/;"	t	typeref:class:Class__class
Class_	cool-tree.h	/^typedef class Class__class *Class_;$/;"	t	typeref:class:Class__class
Class_	cool-tree.handcode.h	/^typedef Class__class *Class_;$/;"	t
Class__EXTRAS	cool-tree.handcode.h	61;"	d
Class__class	cool-tree.h	/^class Class__class : public tree_node {$/;"	c
Classes	ast-parse.h	/^typedef Classes_class *Classes;$/;"	t
Classes	cool-parse.h	/^typedef Classes_class *Classes;$/;"	t
Classes	cool-tree.h	/^typedef Classes_class *Classes;$/;"	t
Classes	cool-tree.handcode.h	/^typedef Classes_class *Classes;$/;"	t
Classes_class	ast-parse.h	/^typedef list_node<Class_> Classes_class;$/;"	t
Classes_class	cool-parse.h	/^typedef list_node<Class_> Classes_class;$/;"	t
Classes_class	cool-tree.h	/^typedef list_node<Class_> Classes_class;$/;"	t
Classes_class	cool-tree.handcode.h	/^typedef list_node<Class_> Classes_class;$/;"	t
DARROW	cool-parse.h	/^     DARROW = 272,$/;"	e	enum:yytokentype
DARROW	cool-parse.h	130;"	d
DEPEND	Makefile	/^DEPEND = ${CC} -MM ${CPPINCLUDE}$/;"	m
DISPATCH	ast-parse.cc	/^     DISPATCH = 266,$/;"	e	enum:yytokentype	file:
DISPATCH	ast-parse.cc	172;"	d	file:
DISPATCH	ast-parse.h	/^     DISPATCH = 266,$/;"	e	enum:yytokentype
DISPATCH	ast-parse.h	132;"	d
DIVIDE	ast-parse.cc	/^     DIVIDE = 275,$/;"	e	enum:yytokentype	file:
DIVIDE	ast-parse.cc	181;"	d	file:
DIVIDE	ast-parse.h	/^     DIVIDE = 275,$/;"	e	enum:yytokentype
DIVIDE	ast-parse.h	141;"	d
ECHO	ast-lex.cc	814;"	d	file:
ELSE	cool-parse.h	/^     ELSE = 259,$/;"	e	enum:yytokentype
ELSE	cool-parse.h	117;"	d
EOB_ACT_CONTINUE_SCAN	ast-lex.cc	218;"	d	file:
EOB_ACT_END_OF_FILE	ast-lex.cc	219;"	d	file:
EOB_ACT_LAST_MATCH	ast-lex.cc	220;"	d	file:
EQ	ast-parse.cc	/^     EQ = 278,$/;"	e	enum:yytokentype	file:
EQ	ast-parse.cc	184;"	d	file:
EQ	ast-parse.h	/^     EQ = 278,$/;"	e	enum:yytokentype
EQ	ast-parse.h	144;"	d
ERROR	cool-parse.h	/^     ERROR = 283,$/;"	e	enum:yytokentype
ERROR	cool-parse.h	141;"	d
ESAC	cool-parse.h	/^     ESAC = 270,$/;"	e	enum:yytokentype
ESAC	cool-parse.h	128;"	d
Entry	stringtab.cc	/^Entry::Entry(char *s, int l, int i) : len(l), index(i) {$/;"	f	class:Entry
Entry	stringtab.h	/^class Entry {$/;"	c
Expression	ast-parse.h	/^typedef class Expression_class *Expression;$/;"	t	typeref:class:Expression_class
Expression	cool-parse.h	/^typedef class Expression_class *Expression;$/;"	t	typeref:class:Expression_class
Expression	cool-tree.h	/^typedef class Expression_class *Expression;$/;"	t	typeref:class:Expression_class
Expression	cool-tree.handcode.h	/^typedef Expression_class *Expression;$/;"	t
Expression_EXTRAS	cool-tree.handcode.h	130;"	d
Expression_SHARED_EXTRAS	cool-tree.handcode.h	140;"	d
Expression_class	cool-tree.h	/^class Expression_class : public tree_node {$/;"	c
Expressions	ast-parse.h	/^typedef Expressions_class *Expressions;$/;"	t
Expressions	cool-parse.h	/^typedef Expressions_class *Expressions;$/;"	t
Expressions	cool-tree.h	/^typedef Expressions_class *Expressions;$/;"	t
Expressions	cool-tree.handcode.h	/^typedef Expressions_class *Expressions;$/;"	t
Expressions_class	ast-parse.h	/^typedef list_node<Expression> Expressions_class;$/;"	t
Expressions_class	cool-parse.h	/^typedef list_node<Expression> Expressions_class;$/;"	t
Expressions_class	cool-tree.h	/^typedef list_node<Expression> Expressions_class;$/;"	t
Expressions_class	cool-tree.handcode.h	/^typedef list_node<Expression> Expressions_class;$/;"	t
FALSE	semant.h	12;"	d
FFLAGS	Makefile	/^FFLAGS = -d8 -ocool-lex.cc$/;"	m
FI	cool-parse.h	/^     FI = 260,$/;"	e	enum:yytokentype
FI	cool-parse.h	118;"	d
FLEX	Makefile	/^FLEX=flex ${FFLAGS}$/;"	m
FLEXINT_H	ast-lex.cc	55;"	d	file:
FLEX_BETA	ast-lex.cc	23;"	d	file:
FLEX_DEBUG	ast-lex.cc	418;"	d	file:
FLEX_SCANNER	ast-lex.cc	18;"	d	file:
FORMAL	ast-parse.cc	/^     FORMAL = 262,$/;"	e	enum:yytokentype	file:
FORMAL	ast-parse.cc	168;"	d	file:
FORMAL	ast-parse.h	/^     FORMAL = 262,$/;"	e	enum:yytokentype
FORMAL	ast-parse.h	128;"	d
Feature	ast-parse.h	/^typedef class Feature_class *Feature;$/;"	t	typeref:class:Feature_class
Feature	cool-parse.h	/^typedef class Feature_class *Feature;$/;"	t	typeref:class:Feature_class
Feature	cool-tree.h	/^typedef class Feature_class *Feature;$/;"	t	typeref:class:Feature_class
Feature	cool-tree.handcode.h	/^typedef Feature_class *Feature;$/;"	t
Feature_EXTRAS	cool-tree.handcode.h	89;"	d
Feature_SHARED_EXTRAS	cool-tree.handcode.h	98;"	d
Feature_class	cool-tree.h	/^class Feature_class : public tree_node {$/;"	c
Features	ast-parse.h	/^typedef Features_class *Features;$/;"	t
Features	cool-parse.h	/^typedef Features_class *Features;$/;"	t
Features	cool-tree.h	/^typedef Features_class *Features;$/;"	t
Features	cool-tree.handcode.h	/^typedef Features_class *Features;$/;"	t
Features_class	ast-parse.h	/^typedef list_node<Feature> Features_class;$/;"	t
Features_class	cool-parse.h	/^typedef list_node<Feature> Features_class;$/;"	t
Features_class	cool-tree.h	/^typedef list_node<Feature> Features_class;$/;"	t
Features_class	cool-tree.handcode.h	/^typedef list_node<Feature> Features_class;$/;"	t
Formal	ast-parse.h	/^typedef class Formal_class *Formal;$/;"	t	typeref:class:Formal_class
Formal	cool-parse.h	/^typedef class Formal_class *Formal;$/;"	t	typeref:class:Formal_class
Formal	cool-tree.h	/^typedef class Formal_class *Formal;$/;"	t	typeref:class:Formal_class
Formal	cool-tree.handcode.h	/^typedef Formal_class *Formal;$/;"	t
Formal_EXTRAS	cool-tree.handcode.h	106;"	d
Formal_class	cool-tree.h	/^class Formal_class : public tree_node {$/;"	c
Formals	ast-parse.h	/^typedef Formals_class *Formals;$/;"	t
Formals	cool-parse.h	/^typedef Formals_class *Formals;$/;"	t
Formals	cool-tree.h	/^typedef Formals_class *Formals;$/;"	t
Formals	cool-tree.handcode.h	/^typedef Formals_class *Formals;$/;"	t
Formals_class	ast-parse.h	/^typedef list_node<Formal> Formals_class;$/;"	t
Formals_class	cool-parse.h	/^typedef list_node<Formal> Formals_class;$/;"	t
Formals_class	cool-tree.h	/^typedef list_node<Formal> Formals_class;$/;"	t
Formals_class	cool-tree.handcode.h	/^typedef list_node<Formal> Formals_class;$/;"	t
GC_DEBUG	cgen_gc.h	/^extern enum Memmgr_Debug { GC_QUICK, GC_DEBUG } cgen_Memmgr_Debug;$/;"	e	enum:Memmgr_Debug
GC_GENGC	cgen_gc.h	/^extern enum Memmgr { GC_NOGC, GC_GENGC, GC_SNCGC } cgen_Memmgr;$/;"	e	enum:Memmgr
GC_NOGC	cgen_gc.h	/^extern enum Memmgr { GC_NOGC, GC_GENGC, GC_SNCGC } cgen_Memmgr;$/;"	e	enum:Memmgr
GC_NORMAL	cgen_gc.h	/^extern enum Memmgr_Test { GC_NORMAL, GC_TEST } cgen_Memmgr_Test;$/;"	e	enum:Memmgr_Test
GC_QUICK	cgen_gc.h	/^extern enum Memmgr_Debug { GC_QUICK, GC_DEBUG } cgen_Memmgr_Debug;$/;"	e	enum:Memmgr_Debug
GC_SNCGC	cgen_gc.h	/^extern enum Memmgr { GC_NOGC, GC_GENGC, GC_SNCGC } cgen_Memmgr;$/;"	e	enum:Memmgr
GC_TEST	cgen_gc.h	/^extern enum Memmgr_Test { GC_NORMAL, GC_TEST } cgen_Memmgr_Test;$/;"	e	enum:Memmgr_Test
HGEN	Makefile	/^HGEN=$/;"	m
ID	ast-parse.cc	/^     ID = 291,$/;"	e	enum:yytokentype	file:
ID	ast-parse.cc	197;"	d	file:
ID	ast-parse.h	/^     ID = 291,$/;"	e	enum:yytokentype
ID	ast-parse.h	157;"	d
IF	cool-parse.h	/^     IF = 261,$/;"	e	enum:yytokentype
IF	cool-parse.h	119;"	d
IN	cool-parse.h	/^     IN = 262,$/;"	e	enum:yytokentype
IN	cool-parse.h	120;"	d
INHERITS	cool-parse.h	/^     INHERITS = 263,$/;"	e	enum:yytokentype
INHERITS	cool-parse.h	121;"	d
INITIAL	ast-lex.cc	690;"	d	file:
INT	ast-parse.cc	/^     INT = 281,$/;"	e	enum:yytokentype	file:
INT	ast-parse.cc	187;"	d	file:
INT	ast-parse.h	/^     INT = 281,$/;"	e	enum:yytokentype
INT	ast-parse.h	147;"	d
INT16_MAX	ast-lex.cc	97;"	d	file:
INT16_MIN	ast-lex.cc	88;"	d	file:
INT32_MAX	ast-lex.cc	100;"	d	file:
INT32_MIN	ast-lex.cc	91;"	d	file:
INT8_MAX	ast-lex.cc	94;"	d	file:
INT8_MIN	ast-lex.cc	85;"	d	file:
INT_CONST	ast-parse.cc	/^     INT_CONST = 290,$/;"	e	enum:yytokentype	file:
INT_CONST	ast-parse.cc	196;"	d	file:
INT_CONST	ast-parse.h	/^     INT_CONST = 290,$/;"	e	enum:yytokentype
INT_CONST	ast-parse.h	156;"	d
INT_CONST	cool-parse.h	/^     INT_CONST = 276,$/;"	e	enum:yytokentype
INT_CONST	cool-parse.h	134;"	d
IO	semant.cc	/^    IO,$/;"	v	file:
ISVOID	ast-parse.cc	/^     ISVOID = 285,$/;"	e	enum:yytokentype	file:
ISVOID	ast-parse.cc	191;"	d	file:
ISVOID	ast-parse.h	/^     ISVOID = 285,$/;"	e	enum:yytokentype
ISVOID	ast-parse.h	151;"	d
ISVOID	cool-parse.h	/^     ISVOID = 274,$/;"	e	enum:yytokentype
ISVOID	cool-parse.h	132;"	d
IdEntry	stringtab.cc	/^IdEntry::IdEntry(char *s, int l, int i) : Entry(s,l,i) { }$/;"	f	class:IdEntry
IdEntry	stringtab.h	/^class IdEntry : public Entry {$/;"	c
IdEntryP	stringtab.h	/^typedef IdEntry *IdEntryP;$/;"	t
IdTable	stringtab.h	/^class IdTable : public StringTable<IdEntry> { };$/;"	c
Int	semant.cc	/^    Int,$/;"	v	file:
IntEntry	stringtab.cc	/^IntEntry::IntEntry(char *s, int l, int i) : Entry(s,l,i) { }$/;"	f	class:IntEntry
IntEntry	stringtab.h	/^class IntEntry: public Entry {$/;"	c
IntEntryP	stringtab.h	/^typedef IntEntry *IntEntryP;$/;"	t
IntTable	stringtab.h	/^class IntTable : public StringTable<IntEntry>$/;"	c
LE	cool-parse.h	/^     LE = 282,$/;"	e	enum:yytokentype
LE	cool-parse.h	140;"	d
LEQ	ast-parse.cc	/^     LEQ = 279,$/;"	e	enum:yytokentype	file:
LEQ	ast-parse.cc	185;"	d	file:
LEQ	ast-parse.h	/^     LEQ = 279,$/;"	e	enum:yytokentype
LEQ	ast-parse.h	145;"	d
LET	ast-parse.cc	/^     LET = 271,$/;"	e	enum:yytokentype	file:
LET	ast-parse.cc	177;"	d	file:
LET	ast-parse.h	/^     LET = 271,$/;"	e	enum:yytokentype
LET	ast-parse.h	137;"	d
LET	cool-parse.h	/^     LET = 264,$/;"	e	enum:yytokentype
LET	cool-parse.h	122;"	d
LET_STMT	cool-parse.h	/^     LET_STMT = 285$/;"	e	enum:yytokentype
LET_STMT	cool-parse.h	142;"	d
LIB	Makefile	/^LIB= -lfl$/;"	m
LIBS	Makefile	/^LIBS= lexer parser cgen$/;"	m
LINENO	ast-parse.cc	/^     LINENO = 292$/;"	e	enum:yytokentype	file:
LINENO	ast-parse.cc	198;"	d	file:
LINENO	ast-parse.h	/^     LINENO = 292$/;"	e	enum:yytokentype
LINENO	ast-parse.h	158;"	d
LOOP	ast-parse.cc	/^     LOOP = 268,$/;"	e	enum:yytokentype	file:
LOOP	ast-parse.cc	174;"	d	file:
LOOP	ast-parse.h	/^     LOOP = 268,$/;"	e	enum:yytokentype
LOOP	ast-parse.h	134;"	d
LOOP	cool-parse.h	/^     LOOP = 265,$/;"	e	enum:yytokentype
LOOP	cool-parse.h	123;"	d
LSRC	Makefile	/^LSRC= Makefile$/;"	m
LT	ast-parse.cc	/^     LT = 277,$/;"	e	enum:yytokentype	file:
LT	ast-parse.cc	183;"	d	file:
LT	ast-parse.h	/^     LT = 277,$/;"	e	enum:yytokentype
LT	ast-parse.h	143;"	d
List	list.h	/^  List(T *h,List<T>* t = NULL): head(h), tail(t) { }$/;"	f	class:List
List	list.h	/^class List {$/;"	c
MAXSIZE	stringtab_functions.h	8;"	d
MAX_STR_CONST	ast-lex.cc	663;"	d	file:
METHOD	ast-parse.cc	/^     METHOD = 260,$/;"	e	enum:yytokentype	file:
METHOD	ast-parse.cc	166;"	d	file:
METHOD	ast-parse.h	/^     METHOD = 260,$/;"	e	enum:yytokentype
METHOD	ast-parse.h	126;"	d
MUL	ast-parse.cc	/^     MUL = 274,$/;"	e	enum:yytokentype	file:
MUL	ast-parse.cc	180;"	d	file:
MUL	ast-parse.h	/^     MUL = 274,$/;"	e	enum:yytokentype
MUL	ast-parse.h	140;"	d
Main	semant.cc	/^    Main,$/;"	v	file:
Memmgr	cgen_gc.h	/^extern enum Memmgr { GC_NOGC, GC_GENGC, GC_SNCGC } cgen_Memmgr;$/;"	g
Memmgr_Debug	cgen_gc.h	/^extern enum Memmgr_Debug { GC_QUICK, GC_DEBUG } cgen_Memmgr_Debug;$/;"	g
Memmgr_Test	cgen_gc.h	/^extern enum Memmgr_Test { GC_NORMAL, GC_TEST } cgen_Memmgr_Test;$/;"	g
NEG	ast-parse.cc	/^     NEG = 276,$/;"	e	enum:yytokentype	file:
NEG	ast-parse.cc	182;"	d	file:
NEG	ast-parse.h	/^     NEG = 276,$/;"	e	enum:yytokentype
NEG	ast-parse.h	142;"	d
NEW	ast-parse.cc	/^     NEW = 284,$/;"	e	enum:yytokentype	file:
NEW	ast-parse.cc	190;"	d	file:
NEW	ast-parse.h	/^     NEW = 284,$/;"	e	enum:yytokentype
NEW	ast-parse.h	150;"	d
NEW	cool-parse.h	/^     NEW = 273,$/;"	e	enum:yytokentype
NEW	cool-parse.h	131;"	d
NOT	cool-parse.h	/^     NOT = 281,$/;"	e	enum:yytokentype
NOT	cool-parse.h	139;"	d
NO_EXPR	ast-parse.cc	/^     NO_EXPR = 286,$/;"	e	enum:yytokentype	file:
NO_EXPR	ast-parse.cc	192;"	d	file:
NO_EXPR	ast-parse.h	/^     NO_EXPR = 286,$/;"	e	enum:yytokentype
NO_EXPR	ast-parse.h	152;"	d
NO_TYPE	ast-parse.cc	/^     NO_TYPE = 288,$/;"	e	enum:yytokentype	file:
NO_TYPE	ast-parse.cc	194;"	d	file:
NO_TYPE	ast-parse.h	/^     NO_TYPE = 288,$/;"	e	enum:yytokentype
NO_TYPE	ast-parse.h	154;"	d
No_class	semant.cc	/^    No_class,$/;"	v	file:
No_type	semant.cc	/^    No_type,$/;"	v	file:
OBJECT	ast-parse.cc	/^     OBJECT = 287,$/;"	e	enum:yytokentype	file:
OBJECT	ast-parse.cc	193;"	d	file:
OBJECT	ast-parse.h	/^     OBJECT = 287,$/;"	e	enum:yytokentype
OBJECT	ast-parse.h	153;"	d
OBJECTID	cool-parse.h	/^     OBJECTID = 279,$/;"	e	enum:yytokentype
OBJECTID	cool-parse.h	137;"	d
OBJS	Makefile	/^OBJS= ${CFIL:.cc=.o}$/;"	m
OF	cool-parse.h	/^     OF = 271,$/;"	e	enum:yytokentype
OF	cool-parse.h	129;"	d
OUTPUT	Makefile	/^OUTPUT= good.output bad.output$/;"	m
Object	semant.cc	/^    Object,$/;"	v	file:
PLUS	ast-parse.cc	/^     PLUS = 272,$/;"	e	enum:yytokentype	file:
PLUS	ast-parse.cc	178;"	d	file:
PLUS	ast-parse.h	/^     PLUS = 272,$/;"	e	enum:yytokentype
PLUS	ast-parse.h	138;"	d
POOL	cool-parse.h	/^     POOL = 266,$/;"	e	enum:yytokentype
POOL	cool-parse.h	124;"	d
PROGRAM	ast-parse.cc	/^     PROGRAM = 258,$/;"	e	enum:yytokentype	file:
PROGRAM	ast-parse.cc	164;"	d	file:
PROGRAM	ast-parse.h	/^     PROGRAM = 258,$/;"	e	enum:yytokentype
PROGRAM	ast-parse.h	124;"	d
Program	ast-parse.h	/^typedef class Program_class *Program;$/;"	t	typeref:class:Program_class
Program	cool-parse.h	/^typedef class Program_class *Program;$/;"	t	typeref:class:Program_class
Program	cool-tree.h	/^typedef class Program_class *Program;$/;"	t	typeref:class:Program_class
Program	cool-tree.handcode.h	/^typedef Program_class *Program;$/;"	t
Program_EXTRAS	cool-tree.handcode.h	49;"	d
Program_class	cool-tree.h	/^class Program_class : public tree_node {$/;"	c
RANLIB	Makefile	/^RANLIB= gar -qs$/;"	m
REJECT	ast-lex.cc	644;"	d	file:
SELF_TYPE	semant.cc	/^    SELF_TYPE,$/;"	v	file:
SEMANT_H_	semant.h	2;"	d
SEMANT_OBJS	Makefile	/^SEMANT_OBJS := ${filter-out symtab_example.o,${OBJS}}$/;"	m
SRC	Makefile	/^SRC= semant.cc semant.h cool-tree.h cool-tree.handcode.h good.cl bad.cl README$/;"	m
STATIC_DISPATCH	ast-parse.cc	/^     STATIC_DISPATCH = 265,$/;"	e	enum:yytokentype	file:
STATIC_DISPATCH	ast-parse.cc	171;"	d	file:
STATIC_DISPATCH	ast-parse.h	/^     STATIC_DISPATCH = 265,$/;"	e	enum:yytokentype
STATIC_DISPATCH	ast-parse.h	131;"	d
STR	ast-parse.cc	/^     STR = 282,$/;"	e	enum:yytokentype	file:
STR	ast-parse.cc	188;"	d	file:
STR	ast-parse.h	/^     STR = 282,$/;"	e	enum:yytokentype
STR	ast-parse.h	148;"	d
STRING	ast-lex.cc	691;"	d	file:
STR_CONST	ast-parse.cc	/^     STR_CONST = 289,$/;"	e	enum:yytokentype	file:
STR_CONST	ast-parse.cc	195;"	d	file:
STR_CONST	ast-parse.h	/^     STR_CONST = 289,$/;"	e	enum:yytokentype
STR_CONST	ast-parse.h	155;"	d
STR_CONST	cool-parse.h	/^     STR_CONST = 275,$/;"	e	enum:yytokentype
STR_CONST	cool-parse.h	133;"	d
SUB	ast-parse.cc	/^     SUB = 273,$/;"	e	enum:yytokentype	file:
SUB	ast-parse.cc	179;"	d	file:
SUB	ast-parse.h	/^     SUB = 273,$/;"	e	enum:yytokentype
SUB	ast-parse.h	139;"	d
Scope	symtab.h	/^   typedef List<ScopeEntry> Scope;$/;"	t	class:SymbolTable
ScopeEntry	symtab.h	/^   typedef SymtabEntry<SYM,DAT> ScopeEntry;$/;"	t	class:SymbolTable
ScopeList	symtab.h	/^   typedef List<Scope> ScopeList;$/;"	t	class:SymbolTable
Str	semant.cc	/^    Str,$/;"	v	file:
StrTable	stringtab.h	/^class StrTable : public StringTable<StringEntry>$/;"	c
StringEntry	stringtab.cc	/^StringEntry::StringEntry(char *s, int l, int i) : Entry(s,l,i) { }$/;"	f	class:StringEntry
StringEntry	stringtab.h	/^class StringEntry : public Entry {$/;"	c
StringEntryP	stringtab.h	/^typedef StringEntry *StringEntryP;$/;"	t
StringTable	stringtab.h	/^   StringTable(): tbl((List<Elem> *) NULL), index(0) { }   \/\/ an empty table$/;"	f	class:StringTable
StringTable	stringtab.h	/^class StringTable$/;"	c
Symbol	ast-parse.h	/^typedef Entry *Symbol;$/;"	t
Symbol	cool-parse.h	/^typedef Entry *Symbol;$/;"	t
Symbol	cool.h	/^typedef Entry *Symbol;$/;"	t
Symbol	stringtab.h	/^typedef Entry* Symbol;$/;"	t
SymbolTable	symtab.h	/^   SymbolTable(): tbl(NULL) { }     \/\/ create a new symbol table$/;"	f	class:SymbolTable
SymbolTable	symtab.h	/^class SymbolTable$/;"	c
SymtabEntry	symtab.h	/^  SymtabEntry(SYM x, DAT *y) : id(x), info(y) { }$/;"	f	class:SymtabEntry
SymtabEntry	symtab.h	/^class SymtabEntry {$/;"	c
THEN	cool-parse.h	/^     THEN = 267,$/;"	e	enum:yytokentype
THEN	cool-parse.h	125;"	d
TREE_H	tree.h	8;"	d
TRUE	semant.h	11;"	d
TSRC	Makefile	/^TSRC= mycoolc mysemant cool-tree.aps$/;"	m
TYPCASE	ast-parse.cc	/^     TYPCASE = 269,$/;"	e	enum:yytokentype	file:
TYPCASE	ast-parse.cc	175;"	d	file:
TYPCASE	ast-parse.h	/^     TYPCASE = 269,$/;"	e	enum:yytokentype
TYPCASE	ast-parse.h	135;"	d
TYPEID	cool-parse.h	/^     TYPEID = 278,$/;"	e	enum:yytokentype
TYPEID	cool-parse.h	136;"	d
UINT16_MAX	ast-lex.cc	106;"	d	file:
UINT32_MAX	ast-lex.cc	109;"	d	file:
UINT8_MAX	ast-lex.cc	103;"	d	file:
WHILE	cool-parse.h	/^     WHILE = 268,$/;"	e	enum:yytokentype
WHILE	cool-parse.h	126;"	d
YYABORT	ast-parse.cc	727;"	d	file:
YYACCEPT	ast-parse.cc	726;"	d	file:
YYBACKUP	ast-parse.cc	739;"	d	file:
YYBISON	ast-parse.cc	46;"	d	file:
YYBISON_VERSION	ast-parse.cc	49;"	d	file:
YYCOPY	ast-parse.cc	420;"	d	file:
YYCOPY	ast-parse.cc	423;"	d	file:
YYDEBUG	ast-parse.cc	103;"	d	file:
YYDPRINTF	ast-parse.cc	819;"	d	file:
YYDPRINTF	ast-parse.cc	968;"	d	file:
YYEMPTY	ast-parse.cc	723;"	d	file:
YYEOF	ast-parse.cc	724;"	d	file:
YYERRCODE	ast-parse.cc	758;"	d	file:
YYERROR	ast-parse.cc	728;"	d	file:
YYERROR_VERBOSE	ast-parse.cc	108;"	d	file:
YYERROR_VERBOSE	ast-parse.cc	109;"	d	file:
YYERROR_VERBOSE	ast-parse.cc	111;"	d	file:
YYFAIL	ast-parse.cc	735;"	d	file:
YYFINAL	ast-parse.cc	453;"	d	file:
YYFPRINTF	ast-parse.cc	816;"	d	file:
YYFREE	ast-parse.cc	386;"	d	file:
YYID	ast-parse.cc	/^YYID (int yyi)$/;"	f	file:
YYID	ast-parse.cc	310;"	d	file:
YYINITDEPTH	ast-parse.cc	977;"	d	file:
YYLAST	ast-parse.cc	455;"	d	file:
YYLEX	ast-parse.cc	806;"	d	file:
YYLEX	ast-parse.cc	808;"	d	file:
YYLLOC_DEFAULT	ast-parse.cc	767;"	d	file:
YYLSP_NEEDED	ast-parse.cc	64;"	d	file:
YYMALLOC	ast-parse.cc	379;"	d	file:
YYMAXDEPTH	ast-parse.cc	988;"	d	file:
YYMAXUTOK	ast-parse.cc	468;"	d	file:
YYNNTS	ast-parse.cc	460;"	d	file:
YYNRULES	ast-parse.cc	462;"	d	file:
YYNSTATES	ast-parse.cc	464;"	d	file:
YYNTOKENS	ast-parse.cc	458;"	d	file:
YYPACT_NINF	ast-parse.cc	640;"	d	file:
YYPOPSTACK	ast-parse.cc	1328;"	d	file:
YYPULL	ast-parse.cc	61;"	d	file:
YYPURE	ast-parse.cc	55;"	d	file:
YYPUSH	ast-parse.cc	58;"	d	file:
YYRECOVERING	ast-parse.cc	737;"	d	file:
YYRHSLOC	ast-parse.cc	765;"	d	file:
YYSIZE_MAXIMUM	ast-parse.cc	287;"	d	file:
YYSIZE_T	ast-parse.cc	275;"	d	file:
YYSIZE_T	ast-parse.cc	277;"	d	file:
YYSIZE_T	ast-parse.cc	281;"	d	file:
YYSIZE_T	ast-parse.cc	283;"	d	file:
YYSKELETON_NAME	ast-parse.cc	52;"	d	file:
YYSTACK_ALLOC	ast-parse.cc	333;"	d	file:
YYSTACK_ALLOC	ast-parse.cc	337;"	d	file:
YYSTACK_ALLOC	ast-parse.cc	342;"	d	file:
YYSTACK_ALLOC	ast-parse.cc	365;"	d	file:
YYSTACK_ALLOC_MAXIMUM	ast-parse.cc	362;"	d	file:
YYSTACK_ALLOC_MAXIMUM	ast-parse.cc	368;"	d	file:
YYSTACK_BYTES	ast-parse.cc	412;"	d	file:
YYSTACK_FREE	ast-parse.cc	356;"	d	file:
YYSTACK_FREE	ast-parse.cc	366;"	d	file:
YYSTACK_GAP_MAXIMUM	ast-parse.cc	408;"	d	file:
YYSTACK_RELOCATE	ast-parse.cc	439;"	d	file:
YYSTATE	ast-lex.cc	176;"	d	file:
YYSTYPE	ast-parse.cc	/^typedef union YYSTYPE$/;"	u	file:
YYSTYPE	ast-parse.cc	/^} YYSTYPE;$/;"	t	typeref:union:YYSTYPE	file:
YYSTYPE	ast-parse.h	/^typedef union YYSTYPE$/;"	u
YYSTYPE	ast-parse.h	/^} YYSTYPE;$/;"	t	typeref:union:YYSTYPE
YYSTYPE	cool-parse.h	/^typedef union YYSTYPE$/;"	u
YYSTYPE	cool-parse.h	/^} YYSTYPE;$/;"	t	typeref:union:YYSTYPE
YYSTYPE_IS_DECLARED	ast-parse.cc	232;"	d	file:
YYSTYPE_IS_DECLARED	ast-parse.h	192;"	d
YYSTYPE_IS_DECLARED	cool-parse.h	176;"	d
YYSTYPE_IS_TRIVIAL	ast-parse.cc	230;"	d	file:
YYSTYPE_IS_TRIVIAL	ast-parse.h	190;"	d
YYSTYPE_IS_TRIVIAL	cool-parse.h	174;"	d
YYTABLES_NAME	ast-lex.cc	2442;"	d	file:
YYTABLE_NINF	ast-parse.cc	669;"	d	file:
YYTERROR	ast-parse.cc	757;"	d	file:
YYTOKENTYPE	ast-parse.cc	122;"	d	file:
YYTOKENTYPE	ast-parse.h	82;"	d
YYTOKENTYPE	cool-parse.h	82;"	d
YYTOKEN_TABLE	ast-parse.cc	116;"	d	file:
YYTRANSLATE	ast-parse.cc	470;"	d	file:
YYUNDEFTOK	ast-parse.cc	467;"	d	file:
YYUSE	ast-parse.cc	303;"	d	file:
YYUSE	ast-parse.cc	305;"	d	file:
YY_	ast-parse.cc	293;"	d	file:
YY_	ast-parse.cc	297;"	d	file:
YY_AT_BOL	ast-lex.cc	413;"	d	file:
YY_BREAK	ast-lex.cc	918;"	d	file:
YY_BUFFER_EOF_PENDING	ast-lex.cc	310;"	d	file:
YY_BUFFER_NEW	ast-lex.cc	298;"	d	file:
YY_BUFFER_NORMAL	ast-lex.cc	299;"	d	file:
YY_BUFFER_STATE	ast-lex.cc	/^typedef struct yy_buffer_state *YY_BUFFER_STATE;$/;"	t	typeref:struct:yy_buffer_state	file:
YY_BUF_SIZE	ast-lex.cc	193;"	d	file:
YY_BUF_SIZE	ast-lex.cc	195;"	d	file:
YY_CHAR	ast-lex.cc	/^typedef unsigned char YY_CHAR;$/;"	t	file:
YY_CURRENT_BUFFER	ast-lex.cc	335;"	d	file:
YY_CURRENT_BUFFER_LVALUE	ast-lex.cc	342;"	d	file:
YY_DECL	ast-lex.cc	903;"	d	file:
YY_DECL_IS_OURS	ast-lex.cc	898;"	d	file:
YY_DO_BEFORE_ACTION	ast-lex.cc	445;"	d	file:
YY_END_OF_BUFFER	ast-lex.cc	456;"	d	file:
YY_END_OF_BUFFER_CHAR	ast-lex.cc	184;"	d	file:
YY_EXIT_FAILURE	ast-lex.cc	2214;"	d	file:
YY_EXTRA_TYPE	ast-lex.cc	706;"	d	file:
YY_FATAL_ERROR	ast-lex.cc	875;"	d	file:
YY_FLEX_MAJOR_VERSION	ast-lex.cc	19;"	d	file:
YY_FLEX_MINOR_VERSION	ast-lex.cc	20;"	d	file:
YY_FLEX_SUBMINOR_VERSION	ast-lex.cc	21;"	d	file:
YY_FLUSH_BUFFER	ast-lex.cc	379;"	d	file:
YY_INPUT	ast-lex.cc	673;"	d	file:
YY_INPUT	ast-lex.cc	674;"	d	file:
YY_INPUT	ast-lex.cc	824;"	d	file:
YY_INT_ALIGNED	ast-lex.cc	5;"	d	file:
YY_LESS_LINENO	ast-lex.cc	222;"	d	file:
YY_LOCATION_PRINT	ast-parse.cc	793;"	d	file:
YY_LOCATION_PRINT	ast-parse.cc	798;"	d	file:
YY_MORE_ADJ	ast-lex.cc	646;"	d	file:
YY_NEW_FILE	ast-lex.cc	182;"	d	file:
YY_NO_UNPUT	ast-lex.cc	664;"	d	file:
YY_NULL	ast-lex.cc	145;"	d	file:
YY_NUM_RULES	ast-lex.cc	455;"	d	file:
YY_READ_BUF_SIZE	ast-lex.cc	802;"	d	file:
YY_READ_BUF_SIZE	ast-lex.cc	804;"	d	file:
YY_REDUCE_PRINT	ast-parse.cc	958;"	d	file:
YY_REDUCE_PRINT	ast-parse.cc	971;"	d	file:
YY_RESTORE_YY_MORE_OFFSET	ast-lex.cc	647;"	d	file:
YY_RULE_SETUP	ast-lex.cc	922;"	d	file:
YY_SC_TO_UI	ast-lex.cc	155;"	d	file:
YY_STACK_PRINT	ast-parse.cc	920;"	d	file:
YY_STACK_PRINT	ast-parse.cc	970;"	d	file:
YY_START	ast-lex.cc	175;"	d	file:
YY_START_STACK_INCR	ast-lex.cc	869;"	d	file:
YY_STATE_BUF_SIZE	ast-lex.cc	201;"	d	file:
YY_STATE_EOF	ast-lex.cc	179;"	d	file:
YY_STRUCT_YY_BUFFER_STATE	ast-lex.cc	246;"	d	file:
YY_SYMBOL_PRINT	ast-parse.cc	825;"	d	file:
YY_SYMBOL_PRINT	ast-parse.cc	969;"	d	file:
YY_TYPEDEF_YY_BUFFER_STATE	ast-lex.cc	204;"	d	file:
YY_TYPEDEF_YY_SIZE_T	ast-lex.cc	241;"	d	file:
YY_USER_ACTION	ast-lex.cc	913;"	d	file:
YY_USE_CONST	ast-lex.cc	124;"	d	file:
YY_USE_CONST	ast-lex.cc	131;"	d	file:
_AST_PARSE_H	ast-parse.h	2;"	d
_COOL_H_	ast-parse.h	10;"	d
_COOL_H_	cool-parse.h	10;"	d
_COOL_H_	cool.h	8;"	d
_COOL_PARSE_H	cool-parse.h	2;"	d
_LIST_H_	list.h	20;"	d
_STDLIB_H	ast-parse.cc	347;"	d	file:
_STDLIB_H	ast-parse.cc	375;"	d	file:
_STRINGTAB_H_	stringtab.h	10;"	d
_SYMTAB_H_	symtab.h	15;"	d
_UTILITIES_H_	utilities.h	9;"	d
__STDC_LIMIT_MACROS	ast-lex.cc	65;"	d	file:
actual	cool-tree.h	/^   Expressions actual;$/;"	m	class:dispatch_class
actual	cool-tree.h	/^   Expressions actual;$/;"	m	class:static_dispatch_class
add_int	stringtab_functions.h	/^Elem *StringTable<Elem>::add_int(int i)$/;"	f	class:StringTable
add_string	stringtab_functions.h	/^Elem *StringTable<Elem>::add_string(char *s)$/;"	f	class:StringTable
add_string	stringtab_functions.h	/^Elem *StringTable<Elem>::add_string(char *s, int maxchars)$/;"	f	class:StringTable
addid	symtab.h	/^   ScopeEntry *addid(SYM s, DAT *i)$/;"	f	class:SymbolTable
alloca	ast-parse.cc	340;"	d	file:
append	tree.h	/^template <class Elem> list_node<Elem> *list_node<Elem>::append(list_node<Elem> *l1,list_node<Elem> *l2) {$/;"	f	class:list_node
append_Cases	cool-tree.cc	/^Cases append_Cases(Cases p1, Cases p2)$/;"	f
append_Classes	cool-tree.cc	/^Classes append_Classes(Classes p1, Classes p2)$/;"	f
append_Expressions	cool-tree.cc	/^Expressions append_Expressions(Expressions p1, Expressions p2)$/;"	f
append_Features	cool-tree.cc	/^Features append_Features(Features p1, Features p2)$/;"	f
append_Formals	cool-tree.cc	/^Formals append_Formals(Formals p1, Formals p2)$/;"	f
append_node	tree.h	/^    append_node(list_node<Elem> *l1, list_node<Elem> *l2) {$/;"	f	class:append_node
append_node	tree.h	/^template <class Elem> class append_node : public list_node<Elem> {$/;"	c
arg	semant.cc	/^arg,$/;"	v	file:
arg2	semant.cc	/^    arg2,$/;"	v	file:
assert_Boolean	cool-tree.handcode.h	/^inline void assert_Boolean(Boolean) {}$/;"	f
assign	cool-tree.cc	/^Expression assign(Symbol name, Expression expr)$/;"	f
assign_class	cool-tree.h	/^   assign_class(Symbol a1, Expression a2) {$/;"	f	class:assign_class
assign_class	cool-tree.h	/^class assign_class : public Expression_class {$/;"	c
ast_file	semant-phase.cc	/^FILE *ast_file = stdin;       \/\/ we read the AST from standard input$/;"	v
ast_root	ast-parse.cc	/^Program ast_root;             \/* the result of the parse  *\/$/;"	v
ast_yyerror	ast-parse.cc	/^void ast_yyerror(char *)$/;"	f
attr	cool-tree.cc	/^Feature attr(Symbol name, Symbol type_decl, Expression init)$/;"	f
attr_class	cool-tree.h	/^   attr_class(Symbol a1, Symbol a2, Expression a3) {$/;"	f	class:attr_class
attr_class	cool-tree.h	/^class attr_class : public Feature_class {$/;"	c
attributes	cool-tree.h	/^   Features attributes;$/;"	m	class:class__class
block	cool-tree.cc	/^Expression block(Expressions body)$/;"	f
block_class	cool-tree.h	/^   block_class(Expressions a1) {$/;"	f	class:block_class
block_class	cool-tree.h	/^class block_class : public Expression_class {$/;"	c
body	cool-tree.h	/^   Expression body;$/;"	m	class:let_class
body	cool-tree.h	/^   Expression body;$/;"	m	class:loop_class
body	cool-tree.h	/^   Expressions body;$/;"	m	class:block_class
bool_const	cool-tree.cc	/^Expression bool_const(Boolean val)$/;"	f
bool_const_class	cool-tree.h	/^   bool_const_class(Boolean a1) {$/;"	f	class:bool_const_class
bool_const_class	cool-tree.h	/^class bool_const_class : public Expression_class {$/;"	c
boolean	ast-parse.cc	/^  Boolean boolean;$/;"	m	union:YYSTYPE	file:
boolean	ast-parse.h	/^  Boolean boolean;$/;"	m	union:YYSTYPE
boolean	cool-parse.h	/^  Boolean boolean;$/;"	m	union:YYSTYPE
branch	cool-tree.cc	/^Case branch(Symbol name, Symbol type_decl, Expression expr)$/;"	f
branch_EXTRAS	cool-tree.handcode.h	125;"	d
branch_class	cool-tree.h	/^   branch_class(Symbol a1, Symbol a2, Expression a3) {$/;"	f	class:branch_class
branch_class	cool-tree.h	/^class branch_class : public Case_class {$/;"	c
case_	ast-parse.cc	/^  Case case_;$/;"	m	union:YYSTYPE	file:
case_	ast-parse.h	/^  Case case_;$/;"	m	union:YYSTYPE
case_	cool-parse.h	/^  Case case_;$/;"	m	union:YYSTYPE
cases	ast-parse.cc	/^  Cases cases;$/;"	m	union:YYSTYPE	file:
cases	ast-parse.h	/^  Cases cases;$/;"	m	union:YYSTYPE
cases	cool-parse.h	/^  Cases cases;$/;"	m	union:YYSTYPE
cases	cool-tree.h	/^   Cases cases;$/;"	m	class:typcase_class
cgen_Memmgr	handle_flags.cc	/^       Memmgr cgen_Memmgr = GC_NOGC;      \/\/ enable\/disable garbage collection$/;"	v
cgen_Memmgr_Debug	handle_flags.cc	/^       Memmgr_Debug cgen_Memmgr_Debug = GC_QUICK; \/\/ check heap frequently$/;"	v
cgen_Memmgr_Test	handle_flags.cc	/^       Memmgr_Test cgen_Memmgr_Test = GC_NORMAL;  \/\/ normal\/test GC$/;"	v
cgen_debug	handle_flags.cc	/^       int cgen_debug;          \/\/ for code gen$/;"	v
cgen_optimize	handle_flags.cc	/^       int cgen_optimize;       \/\/ optimize switch for code generator $/;"	v
check_cycle_inherit	semant.cc	/^bool ClassTable::check_cycle_inherit()$/;"	f	class:ClassTable
check_inherit_Int_String_Bool	semant.cc	/^bool ClassTable::check_inherit_Int_String_Bool()$/;"	f	class:ClassTable
check_inside_let	semant.cc	/^bool class__class::check_inside_let()$/;"	f	class:class__class
check_let_id	semant.cc	/^bool class__class::check_let_id(Symbol id)$/;"	f	class:class__class
check_no_Main_class	semant.cc	/^bool ClassTable::check_no_Main_class()$/;"	f	class:ClassTable
check_no_main_method	semant.cc	/^bool ClassTable::check_no_main_method()$/;"	f	class:ClassTable
check_no_parent	semant.cc	/^void ClassTable::check_no_parent()$/;"	f	class:ClassTable
check_redef_attrs	semant.cc	/^bool ClassTable::check_redef_attrs(Class_ cur_class)$/;"	f	class:ClassTable
check_redef_basic_class	semant.cc	/^bool ClassTable::check_redef_basic_class()$/;"	f	class:ClassTable
check_redef_class	semant.cc	/^bool ClassTable::check_redef_class()$/;"	f	class:ClassTable
check_redef_methods	semant.cc	/^bool ClassTable::check_redef_methods(Class_ cur_class)$/;"	f	class:ClassTable
class_	ast-parse.cc	/^  Class_ class_;$/;"	m	union:YYSTYPE	file:
class_	ast-parse.h	/^  Class_ class_;$/;"	m	union:YYSTYPE
class_	cool-parse.h	/^  Class_ class_;$/;"	m	union:YYSTYPE
class_	cool-tree.cc	/^Class_ class_(Symbol name, Symbol parent, Features features, Symbol filename)$/;"	f
class__EXTRAS	cool-tree.handcode.h	83;"	d
class__class	cool-tree.h	/^   class__class(Symbol a1, Symbol a2, Features a3, Symbol a4) {$/;"	f	class:class__class
class__class	cool-tree.h	/^class class__class : public Class__class {$/;"	c
class_conforms_to	semant.cc	/^bool ClassTable::class_conforms_to(Class_ A, Class_ B)$/;"	f	class:ClassTable
class_tree	semant.h	/^    Classes class_tree;$/;"	m	class:ClassTable
classes	ast-parse.cc	/^  Classes classes;$/;"	m	union:YYSTYPE	file:
classes	ast-parse.h	/^  Classes classes;$/;"	m	union:YYSTYPE
classes	cool-parse.h	/^  Classes classes;$/;"	m	union:YYSTYPE
classes	cool-tree.h	/^   Classes classes;$/;"	m	class:program_class
classes_conform_to	semant.cc	/^bool ClassTable::classes_conform_to(Classes group_A, Class_ B)$/;"	f	class:ClassTable
comp	cool-tree.cc	/^Expression comp(Expression e1)$/;"	f
comp_class	cool-tree.h	/^   comp_class(Expression a1) {$/;"	f	class:comp_class
comp_class	cool-tree.h	/^class comp_class : public Expression_class {$/;"	c
concat	semant.cc	/^    concat,$/;"	v	file:
cond	cool-tree.cc	/^Expression cond(Expression pred, Expression then_exp, Expression else_exp)$/;"	f
cond_class	cool-tree.h	/^   cond_class(Expression a1, Expression a2, Expression a3) {$/;"	f	class:cond_class
cond_class	cool-tree.h	/^class cond_class : public Expression_class {$/;"	c
cons	tree.h	/^template <class Elem> append_node<Elem> *cons(Elem x, list_node<Elem> *l)$/;"	f
cool_abort	semant.cc	/^    cool_abort,$/;"	v	file:
cool_token_to_string	utilities.cc	/^char *cool_token_to_string(int tok)$/;"	f
cool_yydebug	semant-phase.cc	/^int cool_yydebug;     \/\/ not used, but needed to link with handle_flags$/;"	v
cool_yylval	ast-lex.cc	/^YYSTYPE cool_yylval;  \/* needed to link ast code with utilities.cc *\/$/;"	v
copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Case(); }$/;"	f	class:Case_class
copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Class_(); }$/;"	f	class:Class__class
copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Expression(); }$/;"	f	class:Expression_class
copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Feature(); }$/;"	f	class:Feature_class
copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Formal(); }$/;"	f	class:Formal_class
copy	cool-tree.h	/^   tree_node *copy()		 { return copy_Program(); }$/;"	f	class:Program_class
copy	semant.cc	/^    copy,$/;"	v	file:
copy	tree.h	/^    tree_node *copy()            { return copy_list(); }$/;"	f	class:list_node
copy_Boolean	cool-tree.handcode.h	/^inline Boolean copy_Boolean(Boolean b) {return b; }$/;"	f
copy_Case	cool-tree.cc	/^Case branch_class::copy_Case()$/;"	f	class:branch_class
copy_Class_	cool-tree.cc	/^Class_ class__class::copy_Class_()$/;"	f	class:class__class
copy_Expression	cool-tree.cc	/^Expression assign_class::copy_Expression()$/;"	f	class:assign_class
copy_Expression	cool-tree.cc	/^Expression block_class::copy_Expression()$/;"	f	class:block_class
copy_Expression	cool-tree.cc	/^Expression bool_const_class::copy_Expression()$/;"	f	class:bool_const_class
copy_Expression	cool-tree.cc	/^Expression comp_class::copy_Expression()$/;"	f	class:comp_class
copy_Expression	cool-tree.cc	/^Expression cond_class::copy_Expression()$/;"	f	class:cond_class
copy_Expression	cool-tree.cc	/^Expression dispatch_class::copy_Expression()$/;"	f	class:dispatch_class
copy_Expression	cool-tree.cc	/^Expression divide_class::copy_Expression()$/;"	f	class:divide_class
copy_Expression	cool-tree.cc	/^Expression eq_class::copy_Expression()$/;"	f	class:eq_class
copy_Expression	cool-tree.cc	/^Expression int_const_class::copy_Expression()$/;"	f	class:int_const_class
copy_Expression	cool-tree.cc	/^Expression isvoid_class::copy_Expression()$/;"	f	class:isvoid_class
copy_Expression	cool-tree.cc	/^Expression leq_class::copy_Expression()$/;"	f	class:leq_class
copy_Expression	cool-tree.cc	/^Expression let_class::copy_Expression()$/;"	f	class:let_class
copy_Expression	cool-tree.cc	/^Expression loop_class::copy_Expression()$/;"	f	class:loop_class
copy_Expression	cool-tree.cc	/^Expression lt_class::copy_Expression()$/;"	f	class:lt_class
copy_Expression	cool-tree.cc	/^Expression mul_class::copy_Expression()$/;"	f	class:mul_class
copy_Expression	cool-tree.cc	/^Expression neg_class::copy_Expression()$/;"	f	class:neg_class
copy_Expression	cool-tree.cc	/^Expression new__class::copy_Expression()$/;"	f	class:new__class
copy_Expression	cool-tree.cc	/^Expression no_expr_class::copy_Expression()$/;"	f	class:no_expr_class
copy_Expression	cool-tree.cc	/^Expression object_class::copy_Expression()$/;"	f	class:object_class
copy_Expression	cool-tree.cc	/^Expression plus_class::copy_Expression()$/;"	f	class:plus_class
copy_Expression	cool-tree.cc	/^Expression static_dispatch_class::copy_Expression()$/;"	f	class:static_dispatch_class
copy_Expression	cool-tree.cc	/^Expression string_const_class::copy_Expression()$/;"	f	class:string_const_class
copy_Expression	cool-tree.cc	/^Expression sub_class::copy_Expression()$/;"	f	class:sub_class
copy_Expression	cool-tree.cc	/^Expression typcase_class::copy_Expression()$/;"	f	class:typcase_class
copy_Feature	cool-tree.cc	/^Feature attr_class::copy_Feature()$/;"	f	class:attr_class
copy_Feature	cool-tree.cc	/^Feature method_class::copy_Feature()$/;"	f	class:method_class
copy_Formal	cool-tree.cc	/^Formal formal_class::copy_Formal()$/;"	f	class:formal_class
copy_Program	cool-tree.cc	/^Program program_class::copy_Program()$/;"	f	class:program_class
copy_Symbol	stringtab.cc	/^Symbol copy_Symbol(const Symbol s)$/;"	f
copy_list	tree.h	/^template <class Elem> list_node<Elem> *append_node<Elem>::copy_list()$/;"	f	class:append_node
copy_list	tree.h	/^template <class Elem> list_node<Elem> *nil_node<Elem>::copy_list()$/;"	f	class:nil_node
copy_list	tree.h	/^template <class Elem> list_node<Elem> *single_list_node<Elem>::copy_list()$/;"	f	class:single_list_node
curr_filename	semant-phase.cc	/^char *curr_filename;$/;"	v
curr_lineno	semant-phase.cc	/^int curr_lineno;$/;"	v
cycle_inherit_classes	semant.h	/^    Classes cycle_inherit_classes;$/;"	m	class:ClassTable
diffFile	grading/143gradesingle	/^sub diffFile() {$/;"	s
disable_reg_alloc	handle_flags.cc	/^       bool disable_reg_alloc;  \/\/ Don't do register allocation$/;"	v
dispatch	cool-tree.cc	/^Expression dispatch(Expression expr, Symbol name, Expressions actual)$/;"	f
dispatch_class	cool-tree.h	/^   dispatch_class(Expression a1, Symbol a2, Expressions a3) {$/;"	f	class:dispatch_class
dispatch_class	cool-tree.h	/^class dispatch_class : public Expression_class {$/;"	c
divide	cool-tree.cc	/^Expression divide(Expression e1, Expression e2)$/;"	f
divide_class	cool-tree.h	/^   divide_class(Expression a1, Expression a2) {$/;"	f	class:divide_class
divide_class	cool-tree.h	/^class divide_class : public Expression_class {$/;"	c
double_class	semant.h	/^    Class_ double_class;$/;"	m	class:ClassTable
dump	cool-tree.cc	/^void assign_class::dump(ostream& stream, int n)$/;"	f	class:assign_class
dump	cool-tree.cc	/^void attr_class::dump(ostream& stream, int n)$/;"	f	class:attr_class
dump	cool-tree.cc	/^void block_class::dump(ostream& stream, int n)$/;"	f	class:block_class
dump	cool-tree.cc	/^void bool_const_class::dump(ostream& stream, int n)$/;"	f	class:bool_const_class
dump	cool-tree.cc	/^void branch_class::dump(ostream& stream, int n)$/;"	f	class:branch_class
dump	cool-tree.cc	/^void class__class::dump(ostream& stream, int n)$/;"	f	class:class__class
dump	cool-tree.cc	/^void comp_class::dump(ostream& stream, int n)$/;"	f	class:comp_class
dump	cool-tree.cc	/^void cond_class::dump(ostream& stream, int n)$/;"	f	class:cond_class
dump	cool-tree.cc	/^void dispatch_class::dump(ostream& stream, int n)$/;"	f	class:dispatch_class
dump	cool-tree.cc	/^void divide_class::dump(ostream& stream, int n)$/;"	f	class:divide_class
dump	cool-tree.cc	/^void eq_class::dump(ostream& stream, int n)$/;"	f	class:eq_class
dump	cool-tree.cc	/^void formal_class::dump(ostream& stream, int n)$/;"	f	class:formal_class
dump	cool-tree.cc	/^void int_const_class::dump(ostream& stream, int n)$/;"	f	class:int_const_class
dump	cool-tree.cc	/^void isvoid_class::dump(ostream& stream, int n)$/;"	f	class:isvoid_class
dump	cool-tree.cc	/^void leq_class::dump(ostream& stream, int n)$/;"	f	class:leq_class
dump	cool-tree.cc	/^void let_class::dump(ostream& stream, int n)$/;"	f	class:let_class
dump	cool-tree.cc	/^void loop_class::dump(ostream& stream, int n)$/;"	f	class:loop_class
dump	cool-tree.cc	/^void lt_class::dump(ostream& stream, int n)$/;"	f	class:lt_class
dump	cool-tree.cc	/^void method_class::dump(ostream& stream, int n)$/;"	f	class:method_class
dump	cool-tree.cc	/^void mul_class::dump(ostream& stream, int n)$/;"	f	class:mul_class
dump	cool-tree.cc	/^void neg_class::dump(ostream& stream, int n)$/;"	f	class:neg_class
dump	cool-tree.cc	/^void new__class::dump(ostream& stream, int n)$/;"	f	class:new__class
dump	cool-tree.cc	/^void no_expr_class::dump(ostream& stream, int n)$/;"	f	class:no_expr_class
dump	cool-tree.cc	/^void object_class::dump(ostream& stream, int n)$/;"	f	class:object_class
dump	cool-tree.cc	/^void plus_class::dump(ostream& stream, int n)$/;"	f	class:plus_class
dump	cool-tree.cc	/^void program_class::dump(ostream& stream, int n)$/;"	f	class:program_class
dump	cool-tree.cc	/^void static_dispatch_class::dump(ostream& stream, int n)$/;"	f	class:static_dispatch_class
dump	cool-tree.cc	/^void string_const_class::dump(ostream& stream, int n)$/;"	f	class:string_const_class
dump	cool-tree.cc	/^void sub_class::dump(ostream& stream, int n)$/;"	f	class:sub_class
dump	cool-tree.cc	/^void typcase_class::dump(ostream& stream, int n)$/;"	f	class:typcase_class
dump	symtab.h	/^   void dump()$/;"	f	class:SymbolTable
dump	tree.h	/^template <class Elem> void append_node<Elem>::dump(ostream& stream, int n)$/;"	f	class:append_node
dump	tree.h	/^template <class Elem> void nil_node<Elem>::dump(ostream& stream, int n)$/;"	f	class:nil_node
dump	tree.h	/^template <class Elem> void single_list_node<Elem>::dump(ostream& stream, int n)$/;"	f	class:single_list_node
dump_Boolean	cool-tree.handcode.h	/^inline void dump_Boolean(ostream& stream, int padding, Boolean b)$/;"	f
dump_Symbol	stringtab.cc	/^void dump_Symbol(ostream& s, int n, Symbol sym)$/;"	f
dump_cool_token	utilities.cc	/^void dump_cool_token(ostream& out, int lineno, int token, YYSTYPE yylval)$/;"	f
dump_line	dumptype.cc	/^void dump_line(ostream& stream, int n, tree_node *t)$/;"	f
dump_type	dumptype.cc	/^void Expression_class::dump_type(ostream& stream, int n)$/;"	f	class:Expression_class
dump_with_types	dumptype.cc	/^void assign_class::dump_with_types(ostream& stream, int n)$/;"	f	class:assign_class
dump_with_types	dumptype.cc	/^void attr_class::dump_with_types(ostream& stream, int n)$/;"	f	class:attr_class
dump_with_types	dumptype.cc	/^void block_class::dump_with_types(ostream& stream, int n)$/;"	f	class:block_class
dump_with_types	dumptype.cc	/^void bool_const_class::dump_with_types(ostream& stream, int n)$/;"	f	class:bool_const_class
dump_with_types	dumptype.cc	/^void branch_class::dump_with_types(ostream& stream, int n)$/;"	f	class:branch_class
dump_with_types	dumptype.cc	/^void class__class::dump_with_types(ostream& stream, int n)$/;"	f	class:class__class
dump_with_types	dumptype.cc	/^void comp_class::dump_with_types(ostream& stream, int n)$/;"	f	class:comp_class
dump_with_types	dumptype.cc	/^void cond_class::dump_with_types(ostream& stream, int n)$/;"	f	class:cond_class
dump_with_types	dumptype.cc	/^void dispatch_class::dump_with_types(ostream& stream, int n)$/;"	f	class:dispatch_class
dump_with_types	dumptype.cc	/^void divide_class::dump_with_types(ostream& stream, int n)$/;"	f	class:divide_class
dump_with_types	dumptype.cc	/^void eq_class::dump_with_types(ostream& stream, int n)$/;"	f	class:eq_class
dump_with_types	dumptype.cc	/^void formal_class::dump_with_types(ostream& stream, int n)$/;"	f	class:formal_class
dump_with_types	dumptype.cc	/^void int_const_class::dump_with_types(ostream& stream, int n)$/;"	f	class:int_const_class
dump_with_types	dumptype.cc	/^void isvoid_class::dump_with_types(ostream& stream, int n)$/;"	f	class:isvoid_class
dump_with_types	dumptype.cc	/^void leq_class::dump_with_types(ostream& stream, int n)$/;"	f	class:leq_class
dump_with_types	dumptype.cc	/^void let_class::dump_with_types(ostream& stream, int n)$/;"	f	class:let_class
dump_with_types	dumptype.cc	/^void loop_class::dump_with_types(ostream& stream, int n)$/;"	f	class:loop_class
dump_with_types	dumptype.cc	/^void lt_class::dump_with_types(ostream& stream, int n)$/;"	f	class:lt_class
dump_with_types	dumptype.cc	/^void method_class::dump_with_types(ostream& stream, int n)$/;"	f	class:method_class
dump_with_types	dumptype.cc	/^void mul_class::dump_with_types(ostream& stream, int n)$/;"	f	class:mul_class
dump_with_types	dumptype.cc	/^void neg_class::dump_with_types(ostream& stream, int n)$/;"	f	class:neg_class
dump_with_types	dumptype.cc	/^void new__class::dump_with_types(ostream& stream, int n)$/;"	f	class:new__class
dump_with_types	dumptype.cc	/^void no_expr_class::dump_with_types(ostream& stream, int n)$/;"	f	class:no_expr_class
dump_with_types	dumptype.cc	/^void object_class::dump_with_types(ostream& stream, int n)$/;"	f	class:object_class
dump_with_types	dumptype.cc	/^void plus_class::dump_with_types(ostream& stream, int n)$/;"	f	class:plus_class
dump_with_types	dumptype.cc	/^void program_class::dump_with_types(ostream& stream, int n)$/;"	f	class:program_class
dump_with_types	dumptype.cc	/^void static_dispatch_class::dump_with_types(ostream& stream, int n)$/;"	f	class:static_dispatch_class
dump_with_types	dumptype.cc	/^void string_const_class::dump_with_types(ostream& stream, int n)$/;"	f	class:string_const_class
dump_with_types	dumptype.cc	/^void sub_class::dump_with_types(ostream& stream, int n)$/;"	f	class:sub_class
dump_with_types	dumptype.cc	/^void typcase_class::dump_with_types(ostream& stream, int n)$/;"	f	class:typcase_class
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:comp_class
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:divide_class
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:eq_class
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:isvoid_class
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:leq_class
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:lt_class
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:mul_class
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:neg_class
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:plus_class
e1	cool-tree.h	/^   Expression e1;$/;"	m	class:sub_class
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:divide_class
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:eq_class
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:leq_class
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:lt_class
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:mul_class
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:plus_class
e2	cool-tree.h	/^   Expression e2;$/;"	m	class:sub_class
elem	tree.h	/^    Elem elem;$/;"	m	class:single_list_node
else_exp	cool-tree.h	/^   Expression else_exp;$/;"	m	class:cond_class
enterscope	symtab.h	/^   void enterscope()$/;"	f	class:SymbolTable
eq	cool-tree.cc	/^Expression eq(Expression e1, Expression e2)$/;"	f
eq_class	cool-tree.h	/^   eq_class(Expression a1, Expression a2) {$/;"	f	class:eq_class
eq_class	cool-tree.h	/^class eq_class : public Expression_class {$/;"	c
equal_index	stringtab.h	/^  bool equal_index(int ind) const           { return ind == index; }$/;"	f	class:Entry
equal_string	stringtab.cc	/^int Entry::equal_string(char *string, int length) const$/;"	f	class:Entry
error	semant.h	/^static int error = 0;$/;"	v
error_inherit_classes	semant.h	/^    Classes error_inherit_classes;$/;"	m	class:ClassTable
error_msg	cool-parse.h	/^  char *error_msg;$/;"	m	union:YYSTYPE
error_stream	semant.h	/^    ostream& error_stream;$/;"	m	class:ClassTable
errors	semant.h	/^    int errors() { return semant_errors; }$/;"	f	class:ClassTable
exitscope	symtab.h	/^   void exitscope()$/;"	f	class:SymbolTable
expr	cool-tree.h	/^   Expression expr;$/;"	m	class:assign_class
expr	cool-tree.h	/^   Expression expr;$/;"	m	class:branch_class
expr	cool-tree.h	/^   Expression expr;$/;"	m	class:dispatch_class
expr	cool-tree.h	/^   Expression expr;$/;"	m	class:method_class
expr	cool-tree.h	/^   Expression expr;$/;"	m	class:static_dispatch_class
expr	cool-tree.h	/^   Expression expr;$/;"	m	class:typcase_class
expression	ast-parse.cc	/^  Expression expression;$/;"	m	union:YYSTYPE	file:
expression	ast-parse.h	/^  Expression expression;$/;"	m	union:YYSTYPE
expression	cool-parse.h	/^  Expression expression;$/;"	m	union:YYSTYPE
expressions	ast-parse.cc	/^  Expressions expressions;$/;"	m	union:YYSTYPE	file:
expressions	ast-parse.h	/^  Expressions expressions;$/;"	m	union:YYSTYPE
expressions	cool-parse.h	/^  Expressions expressions;$/;"	m	union:YYSTYPE
false_inside_let	semant.cc	/^void class__class::false_inside_let()$/;"	f	class:class__class
fatal_error	symtab.h	/^   void fatal_error(char * msg)$/;"	f	class:SymbolTable
fatal_error	utilities.cc	/^void fatal_error(char *msg)$/;"	f
feature	ast-parse.cc	/^  Feature feature;$/;"	m	union:YYSTYPE	file:
feature	ast-parse.h	/^  Feature feature;$/;"	m	union:YYSTYPE
feature	cool-parse.h	/^  Feature feature;$/;"	m	union:YYSTYPE
features	ast-parse.cc	/^  Features features;$/;"	m	union:YYSTYPE	file:
features	ast-parse.h	/^  Features features;$/;"	m	union:YYSTYPE
features	cool-parse.h	/^  Features features;$/;"	m	union:YYSTYPE
features	cool-tree.h	/^   Features features;$/;"	m	class:class__class
filename	cool-tree.h	/^   Symbol filename;$/;"	m	class:class__class
first	stringtab_functions.h	/^int StringTable<Elem>::first()$/;"	f	class:StringTable
first	tree.h	/^    int first()      { return 0; }$/;"	f	class:list_node
flex_int16_t	ast-lex.cc	/^typedef int16_t flex_int16_t;$/;"	t	file:
flex_int16_t	ast-lex.cc	/^typedef short int flex_int16_t;$/;"	t	file:
flex_int32_t	ast-lex.cc	/^typedef int flex_int32_t;$/;"	t	file:
flex_int32_t	ast-lex.cc	/^typedef int32_t flex_int32_t;$/;"	t	file:
flex_int8_t	ast-lex.cc	/^typedef int8_t flex_int8_t;$/;"	t	file:
flex_int8_t	ast-lex.cc	/^typedef signed char flex_int8_t;$/;"	t	file:
flex_uint16_t	ast-lex.cc	/^typedef uint16_t flex_uint16_t;$/;"	t	file:
flex_uint16_t	ast-lex.cc	/^typedef unsigned short int flex_uint16_t;$/;"	t	file:
flex_uint32_t	ast-lex.cc	/^typedef uint32_t flex_uint32_t;$/;"	t	file:
flex_uint32_t	ast-lex.cc	/^typedef unsigned int flex_uint32_t;$/;"	t	file:
flex_uint8_t	ast-lex.cc	/^typedef uint8_t flex_uint8_t;$/;"	t	file:
flex_uint8_t	ast-lex.cc	/^typedef unsigned char flex_uint8_t; $/;"	t	file:
formal	ast-parse.cc	/^  Formal formal;$/;"	m	union:YYSTYPE	file:
formal	ast-parse.h	/^  Formal formal;$/;"	m	union:YYSTYPE
formal	cool-parse.h	/^  Formal formal;$/;"	m	union:YYSTYPE
formal	cool-tree.cc	/^Formal formal(Symbol name, Symbol type_decl)$/;"	f
formal_EXTRAS	cool-tree.handcode.h	113;"	d
formal_class	cool-tree.h	/^   formal_class(Symbol a1, Symbol a2) {$/;"	f	class:formal_class
formal_class	cool-tree.h	/^class formal_class : public Formal_class {$/;"	c
formals	ast-parse.cc	/^  Formals formals;$/;"	m	union:YYSTYPE	file:
formals	ast-parse.h	/^  Formals formals;$/;"	m	union:YYSTYPE
formals	cool-parse.h	/^  Formals formals;$/;"	m	union:YYSTYPE
formals	cool-tree.h	/^   Formals formals;$/;"	m	class:method_class
get_all_classes	semant.cc	/^Classes ClassTable::get_all_classes()$/;"	f	class:ClassTable
get_attr_by_name	semant.cc	/^Feature class__class::get_attr_by_name(Symbol name)$/;"	f	class:class__class
get_attr_type	semant.cc	/^Symbol class__class::get_attr_type(Symbol name)$/;"	f	class:class__class
get_attrs	semant.cc	/^Features class__class::get_attrs()$/;"	f	class:class__class
get_branch_type	semant.cc	/^Symbol branch_class::get_branch_type()$/;"	f	class:branch_class
get_case_by_type	semant.cc	/^Case typcase_class::get_case_by_type(Symbol var_type)$/;"	f	class:typcase_class
get_children	semant.cc	/^Classes class__class::get_children(Classes classes)$/;"	f	class:class__class
get_class	semant.cc	/^Class_ ClassTable::get_class(Symbol name,Classes classes)$/;"	f	class:ClassTable
get_decl_type	semant.cc	/^Symbol branch_class::get_decl_type()$/;"	f	class:branch_class
get_features	semant.cc	/^Features class__class::get_features()$/;"	f	class:class__class
get_formals	semant.cc	/^Formals attr_class::get_formals()$/;"	f	class:attr_class
get_formals	semant.cc	/^Formals method_class::get_formals()$/;"	f	class:method_class
get_id	symtab.h	/^  SYM get_id() const    { return id; }$/;"	f	class:SymtabEntry
get_info	symtab.h	/^  DAT *get_info() const { return info; }$/;"	f	class:SymtabEntry
get_len	stringtab.cc	/^int Entry::get_len() const$/;"	f	class:Entry
get_line_number	tree.cc	/^int tree_node::get_line_number()$/;"	f	class:tree_node
get_method_by_name	semant.cc	/^Feature class__class::get_method_by_name(Symbol name)$/;"	f	class:class__class
get_methods	semant.cc	/^Features class__class::get_methods()$/;"	f	class:class__class
get_name	semant.cc	/^Symbol attr_class::get_name()$/;"	f	class:attr_class
get_name	semant.cc	/^Symbol class__class::get_name()$/;"	f	class:class__class
get_name	semant.cc	/^Symbol formal_class::get_name()$/;"	f	class:formal_class
get_name	semant.cc	/^Symbol method_class::get_name()$/;"	f	class:method_class
get_parent	semant.cc	/^Symbol class__class::get_parent()$/;"	f	class:class__class
get_string	stringtab.cc	/^char *Entry::get_string() const$/;"	f	class:Entry
get_type	semant.cc	/^Symbol attr_class::get_type()$/;"	f	class:attr_class
get_type	semant.cc	/^Symbol formal_class::get_type()$/;"	f	class:formal_class
get_type	semant.cc	/^Symbol method_class::get_type()$/;"	f	class:method_class
handle_flags	handle_flags.cc	/^void handle_flags(int argc, char *argv[]) {$/;"	f
hd	list.h	/^  T *hd() const       { return head; }  $/;"	f	class:List
head	list.h	/^  T *head;$/;"	m	class:List
id	symtab.h	/^  SYM id;        \/\/ the key field$/;"	m	class:SymtabEntry
identifier	cool-tree.h	/^   Symbol identifier;$/;"	m	class:let_class
idtable	stringtab.cc	/^IdTable idtable;$/;"	v
in_int	semant.cc	/^    in_int,$/;"	v	file:
in_string	semant.cc	/^    in_string,$/;"	v	file:
index	stringtab.h	/^   int index;         \/\/ the current index$/;"	m	class:StringTable
index	stringtab.h	/^  int index;     \/\/ a unique index for each string$/;"	m	class:Entry
info	symtab.h	/^  DAT *info;     \/\/ associated information for the symbol$/;"	m	class:SymtabEntry
init	cool-tree.h	/^   Expression init;$/;"	m	class:attr_class
init	cool-tree.h	/^   Expression init;$/;"	m	class:let_class
initial_inside_let	semant.cc	/^void class__class::initial_inside_let()$/;"	f	class:class__class
initialization	semant.cc	/^void ClassTable::initialization()$/;"	f	class:ClassTable
initialize_constants	semant.cc	/^static void initialize_constants(void)$/;"	f	file:
insert_let_id	semant.cc	/^void class__class::insert_let_id(Symbol id)$/;"	f	class:class__class
inside_let	cool-tree.h	/^   bool inside_let;$/;"	m	class:class__class
install_all_attributes	semant.cc	/^void ClassTable::install_all_attributes(Class_ current, Features inherited)$/;"	f	class:ClassTable
install_all_methods	semant.cc	/^void ClassTable::install_all_methods(Class_ current, Features inherited)$/;"	f	class:ClassTable
install_attributes	semant.cc	/^void class__class::install_attributes(Features inherited)$/;"	f	class:class__class
install_basic_classes	semant.cc	/^void ClassTable::install_basic_classes()$/;"	f	class:ClassTable
install_methods	semant.cc	/^void class__class::install_methods(Features inherited)$/;"	f	class:class__class
int_const	cool-tree.cc	/^Expression int_const(Symbol token)$/;"	f
int_const_class	cool-tree.h	/^   int_const_class(Symbol a1) {$/;"	f	class:int_const_class
int_const_class	cool-tree.h	/^class int_const_class : public Expression_class {$/;"	c
inttable	stringtab.cc	/^IntTable inttable;$/;"	v
is_method	semant.cc	/^bool attr_class::is_method()$/;"	f	class:attr_class
is_method	semant.cc	/^bool method_class::is_method()$/;"	f	class:method_class
isvoid	cool-tree.cc	/^Expression isvoid(Expression e1)$/;"	f
isvoid_class	cool-tree.h	/^   isvoid_class(Expression a1) {$/;"	f	class:isvoid_class
isvoid_class	cool-tree.h	/^class isvoid_class : public Expression_class {$/;"	c
least_type	semant.cc	/^Symbol ClassTable::least_type(Symbol type_A, Symbol type_B)$/;"	f	class:ClassTable
len	stringtab.h	/^  int  len;      \/\/ the length of the string (without trailing \\0)$/;"	m	class:Entry
len	tree.h	/^template <class Elem> int append_node<Elem>::len()$/;"	f	class:append_node
len	tree.h	/^template <class Elem> int nil_node<Elem>::len()$/;"	f	class:nil_node
len	tree.h	/^template <class Elem> int single_list_node<Elem>::len()$/;"	f	class:single_list_node
length	semant.cc	/^    length,$/;"	v	file:
leq	cool-tree.cc	/^Expression leq(Expression e1, Expression e2)$/;"	f
leq_class	cool-tree.h	/^   leq_class(Expression a1, Expression a2) {$/;"	f	class:leq_class
leq_class	cool-tree.h	/^class leq_class : public Expression_class {$/;"	c
let	cool-tree.cc	/^Expression let(Symbol identifier, Symbol type_decl, Expression init, Expression body)$/;"	f
let_class	cool-tree.h	/^   let_class(Symbol a1, Symbol a2, Expression a3, Expression a4) {$/;"	f	class:let_class
let_class	cool-tree.h	/^class let_class : public Expression_class {$/;"	c
let_id	cool-tree.h	/^   vector<Symbol> let_id;$/;"	m	class:class__class
lex_verbose	handle_flags.cc	/^       int lex_verbose;         \/\/ also for the lexer; prints tokens$/;"	v
line_number	tree.h	/^    int line_number;            \/\/ stash the line number when node is made$/;"	m	class:tree_node
lineno	ast-parse.cc	/^  int lineno;$/;"	m	union:YYSTYPE	file:
lineno	ast-parse.h	/^  int lineno;$/;"	m	union:YYSTYPE
list	tree.h	/^template <class Elem> single_list_node<Elem> *list(Elem x)$/;"	f
list_length	list.h	/^int list_length(List<T> *l)$/;"	f
list_map	list.h	/^void list_map(void f(T*), List<T> *l)$/;"	f
list_node	tree.h	/^template <class Elem> class list_node : public tree_node {$/;"	c
list_print	list.h	/^void list_print(S &str, List<T> *l)$/;"	f
lookup	stringtab_functions.h	/^Elem *StringTable<Elem>::lookup(int ind)$/;"	f	class:StringTable
lookup	symtab.h	/^   DAT * lookup(SYM s)$/;"	f	class:SymbolTable
lookup_string	stringtab_functions.h	/^Elem *StringTable<Elem>::lookup_string(char *s)$/;"	f	class:StringTable
loop	cool-tree.cc	/^Expression loop(Expression pred, Expression body)$/;"	f
loop_class	cool-tree.h	/^   loop_class(Expression a1, Expression a2) {$/;"	f	class:loop_class
loop_class	cool-tree.h	/^class loop_class : public Expression_class {$/;"	c
lt	cool-tree.cc	/^Expression lt(Expression e1, Expression e2)$/;"	f
lt_class	cool-tree.h	/^   lt_class(Expression a1, Expression a2) {$/;"	f	class:lt_class
lt_class	cool-tree.h	/^class lt_class : public Expression_class {$/;"	c
main	semant-phase.cc	/^int main(int argc, char *argv[]) {$/;"	f
main	symtab_example.cc	/^int main(int argc, char *argv[]) {$/;"	f
main_meth	semant.cc	/^    main_meth,$/;"	v	file:
method	cool-tree.cc	/^Feature method(Symbol name, Formals formals, Symbol return_type, Expression expr)$/;"	f
method_class	cool-tree.h	/^   method_class(Symbol a1, Formals a2, Symbol a3, Expression a4) {$/;"	f	class:method_class
method_class	cool-tree.h	/^class method_class : public Feature_class {$/;"	c
methods	cool-tree.h	/^   Features methods;$/;"	m	class:class__class
min	stringtab_functions.h	9;"	d
more	stringtab_functions.h	/^int StringTable<Elem>::more(int i)$/;"	f	class:StringTable
more	tree.h	/^    int more(int n)  { return (n < len()); }$/;"	f	class:list_node
mul	cool-tree.cc	/^Expression mul(Expression e1, Expression e2)$/;"	f
mul_class	cool-tree.h	/^   mul_class(Expression a1, Expression a2) {$/;"	f	class:mul_class
mul_class	cool-tree.h	/^class mul_class : public Expression_class {$/;"	c
name	cool-tree.h	/^   Symbol name;$/;"	m	class:assign_class
name	cool-tree.h	/^   Symbol name;$/;"	m	class:attr_class
name	cool-tree.h	/^   Symbol name;$/;"	m	class:branch_class
name	cool-tree.h	/^   Symbol name;$/;"	m	class:class__class
name	cool-tree.h	/^   Symbol name;$/;"	m	class:dispatch_class
name	cool-tree.h	/^   Symbol name;$/;"	m	class:formal_class
name	cool-tree.h	/^   Symbol name;$/;"	m	class:method_class
name	cool-tree.h	/^   Symbol name;$/;"	m	class:object_class
name	cool-tree.h	/^   Symbol name;$/;"	m	class:static_dispatch_class
neg	cool-tree.cc	/^Expression neg(Expression e1)$/;"	f
neg_class	cool-tree.h	/^   neg_class(Expression a1) {$/;"	f	class:neg_class
neg_class	cool-tree.h	/^class neg_class : public Expression_class {$/;"	c
new_	cool-tree.cc	/^Expression new_(Symbol type_name)$/;"	f
new__class	cool-tree.h	/^   new__class(Symbol a1) {$/;"	f	class:new__class
new__class	cool-tree.h	/^class new__class : public Expression_class {$/;"	c
next	stringtab_functions.h	/^int StringTable<Elem>::next(int i)$/;"	f	class:StringTable
next	tree.h	/^    int next(int n)  { return n + 1; }$/;"	f	class:list_node
nil	tree.h	/^template <class Elem> list_node<Elem> *list_node<Elem>::nil() { return new nil_node<Elem>(); }$/;"	f	class:list_node
nil_Cases	cool-tree.cc	/^Cases nil_Cases()$/;"	f
nil_Classes	cool-tree.cc	/^Classes nil_Classes()$/;"	f
nil_Expressions	cool-tree.cc	/^Expressions nil_Expressions()$/;"	f
nil_Features	cool-tree.cc	/^Features nil_Features()$/;"	f
nil_Formals	cool-tree.cc	/^Formals nil_Formals()$/;"	f
nil_node	tree.h	/^template <class Elem> class nil_node : public list_node<Elem> {$/;"	c
no_expr	cool-tree.cc	/^Expression no_expr()$/;"	f
no_expr_class	cool-tree.h	/^   no_expr_class() {$/;"	f	class:no_expr_class
no_expr_class	cool-tree.h	/^class no_expr_class : public Expression_class {$/;"	c
no_parent_classes	semant.h	/^    Classes no_parent_classes;$/;"	m	class:ClassTable
node_lineno	tree.cc	/^int node_lineno = 1;$/;"	v
nth	tree.h	/^template <class Elem> Elem append_node<Elem>::nth(int n)$/;"	f	class:append_node
nth	tree.h	/^template <class Elem> Elem list_node<Elem>::nth(int n)$/;"	f	class:list_node
nth_length	tree.h	/^template <class Elem> Elem append_node<Elem>::nth_length(int n, int &len)$/;"	f	class:append_node
nth_length	tree.h	/^template <class Elem> Elem nil_node<Elem>::nth_length(int, int &len)$/;"	f	class:nil_node
nth_length	tree.h	/^template <class Elem> Elem single_list_node<Elem>::nth_length(int n, int &len)$/;"	f	class:single_list_node
nullexpr	semant.cc	/^bool assign_class::nullexpr()$/;"	f	class:assign_class
nullexpr	semant.cc	/^bool block_class::nullexpr()$/;"	f	class:block_class
nullexpr	semant.cc	/^bool bool_const_class::nullexpr()$/;"	f	class:bool_const_class
nullexpr	semant.cc	/^bool comp_class::nullexpr()$/;"	f	class:comp_class
nullexpr	semant.cc	/^bool cond_class::nullexpr()$/;"	f	class:cond_class
nullexpr	semant.cc	/^bool dispatch_class::nullexpr()$/;"	f	class:dispatch_class
nullexpr	semant.cc	/^bool divide_class::nullexpr()$/;"	f	class:divide_class
nullexpr	semant.cc	/^bool eq_class::nullexpr()$/;"	f	class:eq_class
nullexpr	semant.cc	/^bool int_const_class::nullexpr()$/;"	f	class:int_const_class
nullexpr	semant.cc	/^bool isvoid_class::nullexpr()$/;"	f	class:isvoid_class
nullexpr	semant.cc	/^bool leq_class::nullexpr()$/;"	f	class:leq_class
nullexpr	semant.cc	/^bool let_class::nullexpr()$/;"	f	class:let_class
nullexpr	semant.cc	/^bool loop_class::nullexpr()$/;"	f	class:loop_class
nullexpr	semant.cc	/^bool lt_class::nullexpr()$/;"	f	class:lt_class
nullexpr	semant.cc	/^bool mul_class::nullexpr()$/;"	f	class:mul_class
nullexpr	semant.cc	/^bool neg_class::nullexpr()$/;"	f	class:neg_class
nullexpr	semant.cc	/^bool new__class::nullexpr()$/;"	f	class:new__class
nullexpr	semant.cc	/^bool no_expr_class::nullexpr()$/;"	f	class:no_expr_class
nullexpr	semant.cc	/^bool object_class::nullexpr()$/;"	f	class:object_class
nullexpr	semant.cc	/^bool plus_class::nullexpr()$/;"	f	class:plus_class
nullexpr	semant.cc	/^bool static_dispatch_class::nullexpr()$/;"	f	class:static_dispatch_class
nullexpr	semant.cc	/^bool string_const_class::nullexpr()$/;"	f	class:string_const_class
nullexpr	semant.cc	/^bool sub_class::nullexpr()$/;"	f	class:sub_class
nullexpr	semant.cc	/^bool typcase_class::nullexpr()$/;"	f	class:typcase_class
object	cool-tree.cc	/^Expression object(Symbol name)$/;"	f
object_class	cool-tree.h	/^   object_class(Symbol a1) {$/;"	f	class:object_class
object_class	cool-tree.h	/^class object_class : public Expression_class {$/;"	c
omerrs	ast-parse.cc	/^int omerrs = 0;               \/* number of errors in lexing and parsing *\/$/;"	v
operator <<	stringtab.cc	/^ostream& operator<<(ostream& s, Symbol sym)$/;"	f
operator <<	stringtab.cc	/^ostream& operator<<(ostream& s, const Entry& sym) $/;"	f
operator =	symtab.h	/^   SymbolTable &operator =(const SymbolTable &s) { tbl = s.tbl; return *this; }$/;"	f	class:SymbolTable
out_filename	handle_flags.cc	/^       char *out_filename;      \/\/ file name for generated code$/;"	v
out_int	semant.cc	/^    out_int,$/;"	v	file:
out_string	semant.cc	/^    out_string,$/;"	v	file:
pad	utilities.cc	/^char *pad(int n) {$/;"	f
padding	utilities.cc	/^static char *padding = "                                                                                ";      \/\/ 80 spaces for padding$/;"	v	file:
parent	cool-tree.h	/^   Symbol parent;$/;"	m	class:class__class
parse_results	ast-parse.cc	/^Classes parse_results;        \/* for use in parsing multiple files *\/$/;"	v
plus	cool-tree.cc	/^Expression plus(Expression e1, Expression e2)$/;"	f
plus_class	cool-tree.h	/^   plus_class(Expression a1, Expression a2) {$/;"	f	class:plus_class
plus_class	cool-tree.h	/^class plus_class : public Expression_class {$/;"	c
pred	cool-tree.h	/^   Expression pred;$/;"	m	class:cond_class
pred	cool-tree.h	/^   Expression pred;$/;"	m	class:loop_class
prim_slot	semant.cc	/^    prim_slot,$/;"	v	file:
print	stringtab.cc	/^ostream& Entry::print(ostream& s) const$/;"	f	class:Entry
print	stringtab_functions.h	/^void StringTable<Elem>::print()$/;"	f	class:StringTable
printFile	grading/143gradesingle	/^sub printFile() {$/;"	s
print_cool_token	utilities.cc	/^void print_cool_token(int tok)$/;"	f
print_escaped_string	utilities.cc	/^void print_escaped_string(ostream& str, const char *s)$/;"	f
probe	symtab.h	/^   DAT *probe(SYM s)$/;"	f	class:SymbolTable
program	ast-parse.cc	/^  Program program;$/;"	m	union:YYSTYPE	file:
program	ast-parse.h	/^  Program program;$/;"	m	union:YYSTYPE
program	cool-parse.h	/^  Program program;$/;"	m	union:YYSTYPE
program	cool-tree.cc	/^Program program(Classes classes)$/;"	f
program_EXTRAS	cool-tree.handcode.h	56;"	d
program_class	cool-tree.h	/^   program_class(Classes a1) {$/;"	f	class:program_class
program_class	cool-tree.h	/^class program_class : public Program_class {$/;"	c
redef_branch	semant.cc	/^bool typcase_class::redef_branch()$/;"	f	class:typcase_class
rest	tree.h	/^    list_node<Elem> *some, *rest;$/;"	m	class:append_node
return_type	cool-tree.h	/^   Symbol return_type;$/;"	m	class:method_class
root	semant.h	/^    Class_  root;$/;"	m	class:ClassTable
runPPCmd	grading/143gradesingle	/^sub runPPCmd()$/;"	s
scope	semant.cc	/^SymbolTable<Symbol,Symbol> *scope = new SymbolTable<Symbol,Symbol>();$/;"	v
self	semant.cc	/^    self,$/;"	v	file:
semant	semant.cc	/^void program_class::semant()$/;"	f	class:program_class
semant_debug	handle_flags.cc	/^       int semant_debug;        \/\/ for semantic analysis$/;"	v
semant_error	semant.cc	/^ostream& ClassTable::semant_error()$/;"	f	class:ClassTable
semant_error	semant.cc	/^ostream& ClassTable::semant_error(Class_ c)$/;"	f	class:ClassTable
semant_error	semant.cc	/^ostream& ClassTable::semant_error(Symbol filename, tree_node *t)$/;"	f	class:ClassTable
semant_errors	semant.h	/^    int semant_errors;$/;"	m	class:ClassTable
set	tree.cc	/^tree_node *tree_node::set(tree_node *t) {$/;"	f	class:tree_node
short	ast-parse.cc	243;"	d	file:
single	tree.h	/^template <class Elem> list_node<Elem> *list_node<Elem>::single(Elem e) { return new single_list_node<Elem>(e); }$/;"	f	class:list_node
single_Cases	cool-tree.cc	/^Cases single_Cases(Case e)$/;"	f
single_Classes	cool-tree.cc	/^Classes single_Classes(Class_ e)$/;"	f
single_Expressions	cool-tree.cc	/^Expressions single_Expressions(Expression e)$/;"	f
single_Features	cool-tree.cc	/^Features single_Features(Feature e)$/;"	f
single_Formals	cool-tree.cc	/^Formals single_Formals(Formal e)$/;"	f
single_list_node	tree.h	/^    single_list_node(Elem t) {$/;"	f	class:single_list_node
single_list_node	tree.h	/^template <class Elem> class single_list_node : public list_node<Elem> {$/;"	c
some	tree.h	/^    list_node<Elem> *some, *rest;$/;"	m	class:append_node
static_dispatch	cool-tree.cc	/^Expression static_dispatch(Expression expr, Symbol type_name, Symbol name, Expressions actual)$/;"	f
static_dispatch_class	cool-tree.h	/^   static_dispatch_class(Expression a1, Symbol a2, Symbol a3, Expressions a4) {$/;"	f	class:static_dispatch_class
static_dispatch_class	cool-tree.h	/^class static_dispatch_class : public Expression_class {$/;"	c
str	stringtab.h	/^  char *str;     \/\/ the string$/;"	m	class:Entry
str_field	semant.cc	/^    str_field,$/;"	v	file:
strdup	utilities.cc	/^char *strdup(const char *s)$/;"	f
string_buf	ast-lex.cc	/^char string_buf[MAX_STR_CONST]; \/* to assemble string constants *\/$/;"	v
string_buf_ptr	ast-lex.cc	/^char *string_buf_ptr;$/;"	v
string_const	cool-tree.cc	/^Expression string_const(Symbol token)$/;"	f
string_const_class	cool-tree.h	/^   string_const_class(Symbol a1) {$/;"	f	class:string_const_class
string_const_class	cool-tree.h	/^class string_const_class : public Expression_class {$/;"	c
stringtable	stringtab.cc	/^StrTable stringtable;$/;"	v
sub	cool-tree.cc	/^Expression sub(Expression e1, Expression e2)$/;"	f
sub_class	cool-tree.h	/^   sub_class(Expression a1, Expression a2) {$/;"	f	class:sub_class
sub_class	cool-tree.h	/^class sub_class : public Expression_class {$/;"	c
substr	semant.cc	/^    substr,$/;"	v	file:
symbol	ast-parse.cc	/^  Symbol symbol;$/;"	m	union:YYSTYPE	file:
symbol	ast-parse.h	/^  Symbol symbol;$/;"	m	union:YYSTYPE
symbol	cool-parse.h	/^  Symbol symbol;$/;"	m	union:YYSTYPE
tail	list.h	/^  List<T>* tail;$/;"	m	class:List
tbl	stringtab.h	/^   List<Elem> *tbl;   \/\/ a string table is a list$/;"	m	class:StringTable
tbl	symtab.h	/^   ScopeList  *tbl;$/;"	m	class:SymbolTable
then_exp	cool-tree.h	/^   Expression then_exp;$/;"	m	class:cond_class
tl	list.h	/^  List<T>* tl() const { return tail; }$/;"	f	class:List
token	cool-tree.h	/^   Symbol token;$/;"	m	class:int_const_class
token	cool-tree.h	/^   Symbol token;$/;"	m	class:string_const_class
tree_node	tree.cc	/^tree_node::tree_node()$/;"	f	class:tree_node
tree_node	tree.h	/^class tree_node {$/;"	c
true_inside_let	semant.cc	/^void class__class::true_inside_let()$/;"	f	class:class__class
typcase	cool-tree.cc	/^Expression typcase(Expression expr, Cases cases)$/;"	f
typcase_class	cool-tree.h	/^   typcase_class(Expression a1, Cases a2) {$/;"	f	class:typcase_class
typcase_class	cool-tree.h	/^class typcase_class : public Expression_class {$/;"	c
type	cool-tree.h	/^   Symbol type;$/;"	m	class:branch_class
type_check	semant.cc	/^void assign_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:assign_class
type_check	semant.cc	/^void attr_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:attr_class
type_check	semant.cc	/^void block_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:block_class
type_check	semant.cc	/^void bool_const_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:bool_const_class
type_check	semant.cc	/^void branch_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:branch_class
type_check	semant.cc	/^void class__class::type_check(ClassTable *env, Class_ current)$/;"	f	class:class__class
type_check	semant.cc	/^void comp_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:comp_class
type_check	semant.cc	/^void cond_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:cond_class
type_check	semant.cc	/^void dispatch_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:dispatch_class
type_check	semant.cc	/^void divide_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:divide_class
type_check	semant.cc	/^void eq_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:eq_class
type_check	semant.cc	/^void formal_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:formal_class
type_check	semant.cc	/^void int_const_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:int_const_class
type_check	semant.cc	/^void isvoid_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:isvoid_class
type_check	semant.cc	/^void leq_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:leq_class
type_check	semant.cc	/^void let_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:let_class
type_check	semant.cc	/^void loop_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:loop_class
type_check	semant.cc	/^void lt_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:lt_class
type_check	semant.cc	/^void method_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:method_class
type_check	semant.cc	/^void mul_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:mul_class
type_check	semant.cc	/^void neg_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:neg_class
type_check	semant.cc	/^void new__class::type_check(ClassTable *env, Class_ current)$/;"	f	class:new__class
type_check	semant.cc	/^void no_expr_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:no_expr_class
type_check	semant.cc	/^void object_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:object_class
type_check	semant.cc	/^void plus_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:plus_class
type_check	semant.cc	/^void program_class::type_check(ClassTable *env)$/;"	f	class:program_class
type_check	semant.cc	/^void static_dispatch_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:static_dispatch_class
type_check	semant.cc	/^void string_const_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:string_const_class
type_check	semant.cc	/^void sub_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:sub_class
type_check	semant.cc	/^void typcase_class::type_check(ClassTable *env, Class_ current)$/;"	f	class:typcase_class
type_decl	cool-tree.h	/^   Symbol type_decl;$/;"	m	class:attr_class
type_decl	cool-tree.h	/^   Symbol type_decl;$/;"	m	class:branch_class
type_decl	cool-tree.h	/^   Symbol type_decl;$/;"	m	class:formal_class
type_decl	cool-tree.h	/^   Symbol type_decl;$/;"	m	class:let_class
type_name	cool-tree.h	/^   Symbol type_name;$/;"	m	class:new__class
type_name	cool-tree.h	/^   Symbol type_name;$/;"	m	class:static_dispatch_class
type_name	semant.cc	/^    type_name,$/;"	v	file:
unput	ast-lex.cc	238;"	d	file:
usage	pa3-grading.pl	/^sub usage {$/;"	s
val	cool-tree.h	/^   Boolean val;$/;"	m	class:bool_const_class
val	semant.cc	/^    val;$/;"	v	file:
visitid_classes	semant.h	/^    Classes visitid_classes;$/;"	m	class:ClassTable
writeFile	grading/143gradesingle	/^sub writeFile() {$/;"	s
xcons	tree.h	/^template <class Elem> append_node<Elem> *xcons(list_node<Elem> *l, Elem x)$/;"	f
yy_accept	ast-lex.cc	/^static yyconst flex_int16_t yy_accept[163] =$/;"	v	file:
yy_at_bol	ast-lex.cc	/^	int yy_at_bol;$/;"	m	struct:yy_buffer_state	file:
yy_base	ast-lex.cc	/^static yyconst flex_int16_t yy_base[166] =$/;"	v	file:
yy_bs_column	ast-lex.cc	/^    int yy_bs_column; \/**< The column count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_bs_lineno	ast-lex.cc	/^    int yy_bs_lineno; \/**< The line count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_pos	ast-lex.cc	/^	char *yy_buf_pos;		\/* current position in input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_size	ast-lex.cc	/^	yy_size_t yy_buf_size;$/;"	m	struct:yy_buffer_state	file:
yy_buffer_stack	ast-lex.cc	/^static YY_BUFFER_STATE * yy_buffer_stack = 0; \/**< Stack as an array. *\/$/;"	v	file:
yy_buffer_stack_max	ast-lex.cc	/^static size_t yy_buffer_stack_max = 0; \/**< capacity of stack. *\/$/;"	v	file:
yy_buffer_stack_top	ast-lex.cc	/^static size_t yy_buffer_stack_top = 0; \/**< index of top of stack. *\/$/;"	v	file:
yy_buffer_state	ast-lex.cc	/^struct yy_buffer_state$/;"	s	file:
yy_buffer_status	ast-lex.cc	/^	int yy_buffer_status;$/;"	m	struct:yy_buffer_state	file:
yy_c_buf_p	ast-lex.cc	/^static char *yy_c_buf_p = (char *) 0;$/;"	v	file:
yy_ch_buf	ast-lex.cc	/^	char *yy_ch_buf;		\/* input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_chk	ast-lex.cc	/^static yyconst flex_int16_t yy_chk[217] =$/;"	v	file:
yy_create_buffer	ast-lex.cc	/^    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )$/;"	f
yy_def	ast-lex.cc	/^static yyconst flex_int16_t yy_def[166] =$/;"	v	file:
yy_delete_buffer	ast-lex.cc	/^    void yy_delete_buffer (YY_BUFFER_STATE  b )$/;"	f
yy_did_buffer_switch_on_eof	ast-lex.cc	/^static int yy_did_buffer_switch_on_eof;$/;"	v	file:
yy_ec	ast-lex.cc	/^static yyconst flex_int32_t yy_ec[256] =$/;"	v	file:
yy_fatal_error	ast-lex.cc	/^static void yy_fatal_error (yyconst char* msg )$/;"	f	file:
yy_fill_buffer	ast-lex.cc	/^	int yy_fill_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_flex_debug	ast-lex.cc	/^int yy_flex_debug = 1;$/;"	v
yy_flex_strlen	ast-lex.cc	/^static int yy_flex_strlen (yyconst char * s )$/;"	f	file:
yy_flex_strncpy	ast-lex.cc	/^static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )$/;"	f	file:
yy_flush_buffer	ast-lex.cc	/^    void yy_flush_buffer (YY_BUFFER_STATE  b )$/;"	f
yy_get_next_buffer	ast-lex.cc	/^static int yy_get_next_buffer (void)$/;"	f	file:
yy_get_previous_state	ast-lex.cc	/^    static yy_state_type yy_get_previous_state (void)$/;"	f	file:
yy_hold_char	ast-lex.cc	/^static char yy_hold_char;$/;"	v	file:
yy_init	ast-lex.cc	/^static int yy_init = 0;		\/* whether we need to initialize *\/$/;"	v	file:
yy_init_buffer	ast-lex.cc	/^    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )$/;"	f	file:
yy_init_globals	ast-lex.cc	/^static int yy_init_globals (void)$/;"	f	file:
yy_input_file	ast-lex.cc	/^	FILE *yy_input_file;$/;"	m	struct:yy_buffer_state	file:
yy_is_interactive	ast-lex.cc	/^	int yy_is_interactive;$/;"	m	struct:yy_buffer_state	file:
yy_is_our_buffer	ast-lex.cc	/^	int yy_is_our_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_last_accepting_cpos	ast-lex.cc	/^static char *yy_last_accepting_cpos;$/;"	v	file:
yy_last_accepting_state	ast-lex.cc	/^static yy_state_type yy_last_accepting_state;$/;"	v	file:
yy_load_buffer_state	ast-lex.cc	/^static void yy_load_buffer_state  (void)$/;"	f	file:
yy_meta	ast-lex.cc	/^static yyconst flex_int32_t yy_meta[36] =$/;"	v	file:
yy_n_chars	ast-lex.cc	/^	int yy_n_chars;$/;"	m	struct:yy_buffer_state	file:
yy_n_chars	ast-lex.cc	/^static int yy_n_chars;		\/* number of characters read into yy_ch_buf *\/$/;"	v	file:
yy_new_buffer	ast-lex.cc	391;"	d	file:
yy_nxt	ast-lex.cc	/^	flex_int32_t yy_nxt;$/;"	m	struct:yy_trans_info	file:
yy_nxt	ast-lex.cc	/^static yyconst flex_int16_t yy_nxt[217] =$/;"	v	file:
yy_reduce_print	ast-parse.cc	/^yy_reduce_print (YYSTYPE *yyvsp, int yyrule)$/;"	f	file:
yy_rule_linenum	ast-lex.cc	/^static yyconst flex_int16_t yy_rule_linenum[47] =$/;"	v	file:
yy_scan_buffer	ast-lex.cc	/^YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )$/;"	f
yy_scan_bytes	ast-lex.cc	/^YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )$/;"	f
yy_scan_string	ast-lex.cc	/^YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )$/;"	f
yy_set_bol	ast-lex.cc	403;"	d	file:
yy_set_interactive	ast-lex.cc	393;"	d	file:
yy_size_t	ast-lex.cc	/^typedef size_t yy_size_t;$/;"	t	file:
yy_stack_print	ast-parse.cc	/^yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)$/;"	f	file:
yy_start	ast-lex.cc	/^static int yy_start = 0;	\/* start state number *\/$/;"	v	file:
yy_state_type	ast-lex.cc	/^typedef int yy_state_type;$/;"	t	file:
yy_switch_to_buffer	ast-lex.cc	/^    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )$/;"	f
yy_symbol_print	ast-parse.cc	/^yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	file:
yy_symbol_value_print	ast-parse.cc	/^yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	file:
yy_trans_info	ast-lex.cc	/^struct yy_trans_info$/;"	s	file:
yy_try_NUL_trans	ast-lex.cc	/^    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )$/;"	f	file:
yy_verify	ast-lex.cc	/^	flex_int32_t yy_verify;$/;"	m	struct:yy_trans_info	file:
yyalloc	ast-lex.cc	/^void *yyalloc (yy_size_t  size )$/;"	f
yyalloc	ast-parse.cc	/^union yyalloc$/;"	u	file:
yychar	ast-parse.cc	/^int yychar;$/;"	v
yychar	ast-parse.cc	71;"	d	file:
yycheck	ast-parse.cc	/^static const yytype_int8 yycheck[] =$/;"	v	file:
yyclearin	ast-parse.cc	722;"	d	file:
yyconst	ast-lex.cc	137;"	d	file:
yyconst	ast-lex.cc	139;"	d	file:
yydebug	ast-parse.cc	/^int yydebug;$/;"	v
yydebug	ast-parse.cc	72;"	d	file:
yydefact	ast-parse.cc	/^static const yytype_uint8 yydefact[] =$/;"	v	file:
yydefgoto	ast-parse.cc	/^static const yytype_int8 yydefgoto[] =$/;"	v	file:
yydestruct	ast-parse.cc	/^yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)$/;"	f	file:
yyensure_buffer_stack	ast-lex.cc	/^static void yyensure_buffer_stack (void)$/;"	f	file:
yyerrok	ast-parse.cc	721;"	d	file:
yyerror	ast-parse.cc	69;"	d	file:
yyfree	ast-lex.cc	/^void yyfree (void * ptr )$/;"	f
yyget_debug	ast-lex.cc	/^int yyget_debug  (void)$/;"	f
yyget_in	ast-lex.cc	/^FILE *yyget_in  (void)$/;"	f
yyget_leng	ast-lex.cc	/^int yyget_leng  (void)$/;"	f
yyget_lineno	ast-lex.cc	/^int yyget_lineno  (void)$/;"	f
yyget_out	ast-lex.cc	/^FILE *yyget_out  (void)$/;"	f
yyget_text	ast-lex.cc	/^char *yyget_text  (void)$/;"	f
yyin	ast-lex.cc	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v
yyinput	ast-lex.cc	/^    static int yyinput (void)$/;"	f	file:
yyleng	ast-lex.cc	/^int yyleng;$/;"	v
yyless	ast-lex.cc	2229;"	d	file:
yyless	ast-lex.cc	2230;"	d	file:
yyless	ast-lex.cc	225;"	d	file:
yylex	ast-lex.cc	660;"	d	file:
yylex	ast-parse.cc	68;"	d	file:
yylex_destroy	ast-lex.cc	/^int yylex_destroy  (void)$/;"	f
yylineno	ast-lex.cc	/^int yylineno = 1;$/;"	v
yylineno	ast-parse.cc	87;"	d	file:
yylineno	cool-tree.handcode.h	11;"	d
yylval	ast-lex.cc	659;"	d	file:
yylval	ast-parse.cc	/^YYSTYPE yylval;$/;"	v
yylval	ast-parse.cc	70;"	d	file:
yymore	ast-lex.cc	645;"	d	file:
yynerrs	ast-parse.cc	/^int yynerrs;$/;"	v
yynerrs	ast-parse.cc	73;"	d	file:
yyout	ast-lex.cc	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v
yypact	ast-parse.cc	/^static const yytype_int8 yypact[] =$/;"	v	file:
yyparse	ast-parse.cc	/^yyparse (void *YYPARSE_PARAM)$/;"	f
yyparse	ast-parse.cc	67;"	d	file:
yypgoto	ast-parse.cc	/^static const yytype_int8 yypgoto[] =$/;"	v	file:
yypop_buffer_state	ast-lex.cc	/^void yypop_buffer_state (void)$/;"	f
yyprhs	ast-parse.cc	/^static const yytype_uint8 yyprhs[] =$/;"	v	file:
yypush_buffer_state	ast-lex.cc	/^void yypush_buffer_state (YY_BUFFER_STATE new_buffer )$/;"	f
yyr1	ast-parse.cc	/^static const yytype_uint8 yyr1[] =$/;"	v	file:
yyr2	ast-parse.cc	/^static const yytype_uint8 yyr2[] =$/;"	v	file:
yyrealloc	ast-lex.cc	/^void *yyrealloc  (void * ptr, yy_size_t  size )$/;"	f
yyrestart	ast-lex.cc	/^    void yyrestart  (FILE * input_file )$/;"	f
yyrhs	ast-parse.cc	/^static const yytype_int8 yyrhs[] =$/;"	v	file:
yyrline	ast-parse.cc	/^static const yytype_uint8 yyrline[] =$/;"	v	file:
yyset_debug	ast-lex.cc	/^void yyset_debug (int  bdebug )$/;"	f
yyset_in	ast-lex.cc	/^void yyset_in (FILE *  in_str )$/;"	f
yyset_lineno	ast-lex.cc	/^void yyset_lineno (int  line_number )$/;"	f
yyset_out	ast-lex.cc	/^void yyset_out (FILE *  out_str )$/;"	f
yyss_alloc	ast-parse.cc	/^  yytype_int16 yyss_alloc;$/;"	m	union:yyalloc	file:
yystos	ast-parse.cc	/^static const yytype_uint8 yystos[] =$/;"	v	file:
yystpcpy	ast-parse.cc	/^yystpcpy (char *yydest, const char *yysrc)$/;"	f	file:
yystpcpy	ast-parse.cc	1020;"	d	file:
yystrlen	ast-parse.cc	/^yystrlen (const char *yystr)$/;"	f	file:
yystrlen	ast-parse.cc	997;"	d	file:
yystype	ast-parse.cc	231;"	d	file:
yystype	ast-parse.h	191;"	d
yystype	cool-parse.h	175;"	d
yysyntax_error	ast-parse.cc	/^yysyntax_error (char *yyresult, int yystate, int yychar)$/;"	f	file:
yytable	ast-parse.cc	/^static const yytype_uint8 yytable[] =$/;"	v	file:
yyterminate	ast-lex.cc	864;"	d	file:
yytext	ast-lex.cc	/^char *yytext;$/;"	v
yytext_ptr	ast-lex.cc	431;"	d	file:
yytname	ast-parse.cc	/^static const char *const yytname[] =$/;"	v	file:
yytnamerr	ast-parse.cc	/^yytnamerr (char *yyres, const char *yystr)$/;"	f	file:
yytokentype	ast-parse.cc	/^   enum yytokentype {$/;"	g	file:
yytokentype	ast-parse.h	/^   enum yytokentype {$/;"	g
yytokentype	cool-parse.h	/^   enum yytokentype {$/;"	g
yytoknum	ast-parse.cc	/^static const yytype_uint16 yytoknum[] =$/;"	v	file:
yytranslate	ast-parse.cc	/^static const yytype_uint8 yytranslate[] =$/;"	v	file:
yytype_int16	ast-parse.cc	/^typedef YYTYPE_INT16 yytype_int16;$/;"	t	file:
yytype_int16	ast-parse.cc	/^typedef short int yytype_int16;$/;"	t	file:
yytype_int8	ast-parse.cc	/^typedef YYTYPE_INT8 yytype_int8;$/;"	t	file:
yytype_int8	ast-parse.cc	/^typedef short int yytype_int8;$/;"	t	file:
yytype_int8	ast-parse.cc	/^typedef signed char yytype_int8;$/;"	t	file:
yytype_uint16	ast-parse.cc	/^typedef YYTYPE_UINT16 yytype_uint16;$/;"	t	file:
yytype_uint16	ast-parse.cc	/^typedef unsigned short int yytype_uint16;$/;"	t	file:
yytype_uint8	ast-parse.cc	/^typedef YYTYPE_UINT8 yytype_uint8;$/;"	t	file:
yytype_uint8	ast-parse.cc	/^typedef unsigned char yytype_uint8;$/;"	t	file:
yyunput	ast-lex.cc	/^    static void yyunput (int c, register char * yy_bp )$/;"	f	file:
yyvs_alloc	ast-parse.cc	/^  YYSTYPE yyvs_alloc;$/;"	m	union:yyalloc	file:
~list_node	tree.h	/^    virtual ~list_node() { }$/;"	f	class:list_node
~tree_node	tree.h	/^    virtual ~tree_node() { }$/;"	f	class:tree_node
